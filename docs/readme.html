<!DOCTYPE html> <html lang="en"><head>
<title>README</title>
<base href=".">
<meta name="pathname" content="readme.html">
<meta name="description" content="trie-material - README">
<meta property="og:title" content="README">
<meta property="og:description" content="trie-material - README">
<meta property="og:type" content="website">
<meta property="og:url" content="readme.html">
<meta property="og:image" content="assets/capa_video.png">
<meta charset="UTF-8"><meta property="og:site_name" content="trie-material"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="site-lib/rss.xml"><script async="" id="webpage-script" src="site-lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-wasm-script" src="site-lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="site-lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="site-lib/media/favicon.png"><link rel="stylesheet" href="site-lib/styles/obsidian.css"><link rel="preload" href="site-lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="site-lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="site-lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="site-lib/styles/main-styles.css"></noscript><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-vertical-spacing:1.3em;--sidebar-margin:12px}:root{background-color:#202124}.sidebar{height:100%;font-size:14px;z-index:10;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));position:relative;overflow:hidden;overflow:clip;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}#left-sidebar{left:0}#right-sidebar{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}.sidebar.floating{position:absolute}.sidebar .leaf-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .leaf-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}#left-sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}#right-sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar #left-sidebar-content,.sidebar #right-sidebar-content{contain:none!important;container-type:normal!important;animation:none!important}.sidebar:has(.leaf-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:calc(2.3em + 2 * var(--sidebar-margin));width:var(--sidebar-width);padding:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}#left-sidebar .sidebar-topbar{left:0;flex-direction:row;border-top-right-radius:var(--radius-l)}#right-sidebar .sidebar-topbar{right:0;flex-direction:row-reverse;border-top-left-radius:var(--radius-l)}#left-sidebar .topbar-content{margin-right:calc(2.3em + var(--sidebar-margin));flex-direction:row}#right-sidebar .topbar-content{margin-left:calc(2.3em + var(--sidebar-margin));flex-direction:row-reverse}.topbar-content{overflow:hidden visible;overflow:clip visible;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:2px!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}#left-sidebar .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}#right-sidebar .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.feature-title{margin-left:1px;text-transform:uppercase;letter-spacing:.06em;margin-top:.75em;margin-bottom:.75em}.feature-header{display:flex;align-items:center;padding-top:0;font-size:1em;padding-left:0}body.floating-sidebars .sidebar{position:absolute}body{transition:background-color var(--color-fade-speed) ease-in-out}#navbar:not(:empty){display:flex;align-items:center;justify-content:space-between;padding:.5em 1em;width:100%}#main{display:flex;flex-direction:column;height:100%;width:100%;align-items:stretch;justify-content:center}#main-horizontal{display:flex;flex-direction:row;flex-grow:1;width:100%;align-items:stretch;justify-content:center}#center-content{flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0!important;transition:opacity .2s ease-in-out;pointer-events:none}#center-content>.obsidian-document{padding-left:2em;padding-right:1em;margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}body #center-content>.obsidian-document>.markdown-preview-sizer{padding-bottom:80vh;width:100%;max-width:var(--line-width);flex-basis:var(--line-width);transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}#center-content>.obsidian-document>div{width:100%!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}#center-content>.obsidian-document:not([data-type=markdown]).embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}#center-content>.obsidian-document:not([data-type=markdown]).embed>*{max-width:100%;max-height:100%;object-fit:contain}:not(h1,h2,h3,h4,h5,h6,li):has(> :is(.math,table)){overflow-x:auto!important}#center-content>.obsidian-document:not([data-type=markdown]){overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.obsidian-document[data-type=attachment]{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;width:100%}.obsidian-document[data-type=attachment]>*{outline:0;border:none;box-shadow:none}.obsidian-document[data-type=attachment] :is(img){max-width:90%;max-height:90%;object-fit:contain}.obsidian-document[data-type=attachment]>:is(audio){width:100%;max-width:min(90%,var(--line-width))}.obsidian-document[data-type=attachment]>:is(embed,iframe,video){width:100%;height:100%;max-width:100%;max-height:100%;object-fit:contain}.canvas-wrapper>:is(.header,.footer){z-index:100;position:absolute;display:flex;justify-content:center;flex-direction:column;width:100%;align-items:center}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){let e=document.querySelectorAll("link[itemprop='include']");for(const t of e){let e=t.getAttribute("href");try{let o="";if(e.startsWith("https:")||e.startsWith("http:")||"file:"!=window.location.protocol){const n=await fetch(e);if(!n.ok){console.log("Could not include file: "+e),t?.remove();continue}o=await n.text()}else{const t=document.getElementById(btoa(encodeURI(e)));if(t){const e=JSON.parse(decodeURI(atob(t.getAttribute("value")??"")));o=e?.data??""}}let n=document.createRange().createContextualFragment(o);t.before(n),t.remove(),console.log("Included text: "+o),console.log("Included file: "+e)}catch(o){t?.remove(),console.log("Could not include file: "+e,o);continue}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script")));!function e(n){let l=o[n],c=n+1;l?(l&&"true"!=l.getAttribute("loaded")||n<o.length&&e(c),n<o.length&&l.addEventListener("load",(()=>e(c)))):n<o.length?e(c):t()}(0)}</script></head><body class="publish css-settings-manager styled-scrollbars show-inline-title show-ribbon is-focused"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="parsed-feature-container" style="display: contents;"><link itemprop="include" href="site-lib/html/custom-head-content-content.html"></div><div id="main"><div id="navbar"></div><div id="main-horizontal"><div id="left-content" class="leaf" style="--sidebar-width: var(--sidebar-width-left);"><div id="left-sidebar" class="sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><div id="search-container"><div id="search-wrapper"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div aria-label="Clear search" id="search-clear-button"></div></div></div></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content-wrapper"><div id="left-sidebar-content" class="leaf-content"><link itemprop="include" href="site-lib/html/file-tree-content.html"></div></div><script defer="">let ls = document.querySelector("#left-sidebar"); ls.classList.toggle("is-collapsed", window.innerWidth < 768); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div></div><div id="center-content" class="leaf"><div class="obsidian-document markdown-preview-view markdown-rendered node-insert-event is-readable-line-width allow-fold-headings allow-fold-lists show-indentation-guide show-properties" data-type="markdown"><style id="MJX-CHTML-styles">mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block;text-align:left}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-mi{display:inline-block;text-align:left}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-msup{display:inline-block;text-align:left}mjx-mn{display:inline-block;text-align:left}mjx-msub{display:inline-block;text-align:left}mjx-texatom{display:inline-block;text-align:left}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("site-lib/fonts/mathjax_zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("site-lib/fonts/mathjax_main-regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("site-lib/fonts/mathjax_main-bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("site-lib/fonts/mathjax_math-italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("site-lib/fonts/mathjax_main-italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("site-lib/fonts/mathjax_math-bolditalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("site-lib/fonts/mathjax_size1-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("site-lib/fonts/mathjax_size2-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("site-lib/fonts/mathjax_size3-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("site-lib/fonts/mathjax_size4-regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("site-lib/fonts/mathjax_ams-regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("site-lib/fonts/mathjax_calligraphic-regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("site-lib/fonts/mathjax_calligraphic-bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("site-lib/fonts/mathjax_fraktur-regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("site-lib/fonts/mathjax_fraktur-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("site-lib/fonts/mathjax_sansserif-regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("site-lib/fonts/mathjax_sansserif-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("site-lib/fonts/mathjax_sansserif-italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("site-lib/fonts/mathjax_script-regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("site-lib/fonts/mathjax_typewriter-regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("site-lib/fonts/mathjax_vector-regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("site-lib/fonts/mathjax_vector-bold.woff") format("woff")}mjx-c.mjx-c1D442.TEX-I::before{padding:.704em .763em .022em 0;content:"O"}mjx-c.mjx-c28::before{padding:.75em .389em .25em 0;content:"("}mjx-c.mjx-c1D43F.TEX-I::before{padding:.683em .681em 0 0;content:"L"}mjx-c.mjx-c29::before{padding:.75em .389em .25em 0;content:")"}mjx-c.mjx-c31::before{padding:.666em .5em 0 0;content:"1"}mjx-c.mjx-c30::before{padding:.666em .5em .022em 0;content:"0"}mjx-c.mjx-c36::before{padding:.666em .5em .022em 0;content:"6"}mjx-c.mjx-c2264::before{padding:.636em .778em .138em 0;content:"≤"}mjx-c.mjx-c1D45B.TEX-I::before{padding:.442em .6em .011em 0;content:"n"}mjx-c.mjx-c33::before{padding:.665em .5em .022em 0;content:"3"}mjx-c.mjx-c22C5::before{padding:.31em .278em 0 0;content:"⋅"}mjx-c.mjx-c35::before{padding:.666em .5em .022em 0;content:"5"}mjx-c.mjx-c2C::before{padding:.121em .278em .194em 0;content:","}mjx-c.mjx-c1D45A.TEX-I::before{padding:.442em .878em .011em 0;content:"m"}mjx-c.mjx-c1D446.TEX-I::before{padding:.705em .645em .022em 0;content:"S"}mjx-c.mjx-c1D441.TEX-I::before{padding:.683em .888em 0 0;content:"N"}mjx-c.mjx-c200B::before{padding:0;content:""}mjx-c.mjx-c2B::before{padding:.583em .778em .082em 0;content:"+"}mjx-c.mjx-c1D444.TEX-I::before{padding:.704em .791em .194em 0;content:"Q"}mjx-c.mjx-c2211.TEX-S1::before{padding:.75em 1.056em .25em 0;content:"∑"}mjx-c.mjx-c7C::before{padding:.75em .278em .249em 0;content:"|"}mjx-c.mjx-c1D456.TEX-I::before{padding:.661em .345em .011em 0;content:"i"}mjx-c.mjx-c1D450.TEX-I::before{padding:.442em .433em .011em 0;content:"c"}mjx-c.mjx-c1D458.TEX-I::before{padding:.694em .521em .011em 0;content:"k"}mjx-c.mjx-c2223::before{padding:.75em .278em .249em 0;content:"∣"}mjx-c.mjx-c61::before{padding:.448em .5em .011em 0;content:"a"}mjx-c.mjx-c6C::before{padding:.694em .278em 0 0;content:"l"}mjx-c.mjx-c66::before{padding:.705em .372em 0 0;content:"f"}mjx-c.mjx-c62::before{padding:.694em .556em .011em 0;content:"b"}mjx-c.mjx-c65::before{padding:.448em .444em .011em 0;content:"e"}mjx-c.mjx-c74::before{padding:.615em .389em .01em 0;content:"t"}mjx-c.mjx-c6F::before{padding:.448em .5em .01em 0;content:"o"}mjx-c.mjx-c32::before{padding:.666em .5em 0 0;content:"2"}mjx-c.mjx-c2026::before{padding:.12em 1.172em 0 0;content:"…"}mjx-c.mjx-c1D43E.TEX-I::before{padding:.683em .889em 0 0;content:"K"}</style><div class="markdown-preview-sizer markdown-preview-section"><div class="header"><h1 class="page-title heading inline-title" id="README_0">README</h1><div class="data-bar"></div></div><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="el-h1"><h1 data-heading="1 Motivação" dir="auto" class="heading" id="1_Motivação_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>1 Motivação</h1></div><div class="el-p"><p dir="auto">Imagina o autocompletar do seu celular, ao digitar "comp", magicamente aparecem opções como "computação", "computador", "compilador". Mas como é possível fazer isso de forma tão rápida, mesmo com uma imensidão de palavras?</p></div><div class="el-p"><p dir="auto">Se tentassemos resolver esse problema com estruturas de dados comuns, como:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><strong>Listas ou array:</strong> somos forçados a fazer uma busca exaustiva, olhar cada palavra, uma por uma, e perguntar "você começa com 'comp'?", o que é terrivelmente lento.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><strong>Tabela hash:</strong> ela transforma uma palavra inteira em um código numérico para uma busca instantânea. O problema é que esse processo destrói a informação do prefixo. O código de "computador" não tem relação nenhuma com o de "componente". Portanto, somos forçados a pegar cada chave da tabela e verificar cada uma individualmente.</li>
</ul></div><div class="el-p"><p dir="auto">É exatamente para isso que a Trie foi criada, ela é perfeita para problemas em dados sequênciais, para aqueles que envolvem operações com prefixos.</p></div><div class="el-p"><p dir="auto">Então, se as estruturas clássicas não nos ajuda nesse caso, qual é a mágica? A magia da trie é invés de encarar as sequências como um bloco único, "computador" por exemplo, ele olha como um caminho <code>c -&gt; o -&gt; m -&gt; p -&gt; ...</code>. A busca vira um passeio pela árvore.</p></div><div class="el-h1"><h1 data-heading="2 Visão Geral em Vídeo: Trie em 3 Minutos" dir="auto" class="heading" id="2_Visão_Geral_em_Vídeo_Trie_em_3_Minutos_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>2 Visão Geral em Vídeo: Trie em 3 Minutos</h1></div><div class="el-p"><p dir="auto"><a data-tooltip-position="top" aria-label="https://drive.google.com/file/d/1IdA_raSGxST6bzsXCbgNaLiKSR3GiWeB/view?usp=drivesdk" rel="noopener nofollow" class="external-link is-unresolved" href="https://drive.google.com/file/d/1IdA_raSGxST6bzsXCbgNaLiKSR3GiWeB/view?usp=drivesdk" target="_self"><span alt="Assista à demonstração do projeto" src="assets/capa_video.png" class="internal-embed media-embed image-embed is-loaded" target="_self"><img alt="Assista à demonstração do projeto" src="assets/capa_video.png" target="_self"></span></a></p></div><div class="el-h1"><h1 data-heading="3 Introdução" dir="auto" class="heading" id="3_Introdução_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>3 Introdução</h1></div><div class="el-h2"><h2 data-heading="3.1 O que é uma Trie?" dir="auto" class="heading" id="3.1_O_que_é_uma_Trie?_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>3.1 O que é uma Trie?</h2></div><div class="el-p"><p dir="auto">Também conhecida como árvore de prefixos, é uma estrutura de dados usada para armazenar sequências de forma dinâmica, facilitando operações com prefixos. Algo interessante sobre a Trie, é que os nós não armazenam a chave, mas o caminho da raiz até um nó representa a chave (ou prefixo).</p></div><div class="el-h2"><h2 data-heading="3.2 Visualizando" dir="auto" class="heading" id="3.2_Visualizando_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>3.2 Visualizando</h2></div><div class="el-p"><p dir="auto">Vamos ver como as palavras "galo", "gato", e "gado" seriam armazenadas em uma Trie:</p></div><div class="el-p"><p align="center" dir="auto"><img height="400" src="assets/introduction_visualization_trie.png" referrerpolicy="no-referrer" target="_self"></p></div><div class="el-p"><p dir="auto">A estrutura de uma Trie é composta por:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>Raiz:</strong> ele não representa nenhum valor do alfabeto e serve como o ancestral comum de todas as palavras.</li>
<li data-line="1" dir="auto"><strong>Arestas e nós:</strong> cada nó pode ter vários filhos, e representa um possível caminho de palavra. Por exemplo, a letra <em>a</em> pode levar para <em>l</em>, <em>t</em>, ou <em>d</em>.</li>
<li data-line="2" dir="auto"><strong>Compartilhamento de prefixo:</strong> observe que as três palavras compartilham do prefixo "ga", então em vez de armazenar ele 3 vezes, ela armazena apenas 1 vez.</li>
<li data-line="3" dir="auto"><strong>Marcador de fim:</strong> como sabemos que a palavra "galo" é uma palavra mas "gal" é um prefixo? Adicionando um marcador booleano no final de cada palavra.</li>
</ol></div><div class="el-h1"><h1 data-heading="4 Implementação" dir="auto" class="heading" id="4_Implementação_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>4 Implementação</h1></div><div class="el-h2"><h2 data-heading="4.1 Estruturas fundamentais" dir="auto" class="heading" id="4.1_Estruturas_fundamentais_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>4.1 Estruturas fundamentais</h2></div><div class="el-h3"><h3 data-heading="4.1.1 Node" dir="auto" class="heading" id="4.1.1_Node_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>4.1.1 Node</h3></div><div class="el-p"><p dir="auto">Os nós na implementação de uma Trie, assim como em Linked Lists ou outra estrutura que os utilize, são as peças do quebra-cabeça. Sem eles, não existe implementação.</p></div><div class="el-h4"><h4 data-heading="4.1.1.1 Atributos" dir="auto" class="heading" id="4.1.1.1_Atributos_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>4.1.1.1 Atributos</h4></div><div class="el-p"><p dir="auto">A primeira vista pode ser estranho e incomum, mas o nó não armazena o valor que representa dentro da estrutura da Trie, pois aqui, não temos um nó que se linka com outro através de apontadores como "left" ou "right", os nós armazenam algo mais interessante...</p></div><div class="el-p"><p dir="auto"><strong>HashMap:</strong> </p></div><div class="el-p"><p dir="auto">Para fins didáticos, nossa implementação aborda a manipulação de palavras na Trie e as armazena em um HashMap. Caso você pare um pouco para pensar, verá que de acordo com nossa abordagem, o HashMap guardará no máximo 26 pares de &lt;Chave, Valor&gt;, onde a chave é cada letra do alfabeto, e seu valor é o nó que o representa. Desta forma, podemos pesquisar por várias palavras que contenham o mesmo prefixo com a mesma eficiência.</p></div><div class="el-p"><p dir="auto"><strong>Indicador de fim de palavra:</strong></p></div><div class="el-p"><p dir="auto">Este atributo é extremamente importante para o funcionamento da Trie por definir se uma palavra está presente na  estrutura ou não. Ele é um atributo booleano que define se certa letra representa o fim de uma palavra dentro da Trie. </p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>
<p><strong>Exemplo:</strong></p>
<blockquote dir="auto">
<p>Digamos que adicionamos a palavra "Carrossel".</p>
<p>Nossa estrutura ficaria assim: ROOT -&gt; C -&gt; A -&gt; R -&gt; R -&gt; O -&gt; S -&gt; S -&gt; E -&gt; <b>L</b></p>
<p>Podemos pesquisá-la através do método search que veremos adiante, e o retorno será <strong>true</strong>, pois ela foi inserida. Agora caso pesquisarmos pela palavra "Carro", comumente se pensaria que ela está ao visualizar a estrutura que temos, porém ela nunca foi adicionada. Para isso que temos nosso atributo mágico "wordEnd", que define se certo nó que representa uma letra n também se refere ao fim de uma palavra. Nosso algoritmo olharia para o nó que representa a letra "o" da <strong>nossa estrutura</strong> e se perguntaria "Esta letra é o fim de uma palavra?". E no nosso caso, essa resposta seria <strong>false</strong>.</p>
</blockquote>
</li>
<li data-line="7" dir="auto"><span class="list-bullet"></span>
<p>Veja a implementação da classe Node (Atributos e construtor):</p>
</li>
</ul></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>

    <span class="token keyword">boolean</span> wordEnd<span class="token punctuation">;</span>
    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> sons<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>wordEnd <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>sons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Para a realização das operações, ela conta com os seguintes métodos:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>getSons(): Retorna o mapa de filhos do nó.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>isEndOfWord(): Retorna o valor do atributo wordEnd.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>setEndOfWord(): Torna true o valor do atributo wordEnd.</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span>turnOffEndOfWord(): Torna false o valor do atributo wordEnd.</li>
</ul></div><div class="el-h3"><h3 data-heading="4.1.2 Trie" dir="auto" class="heading" id="4.1.2_Trie_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>4.1.2 Trie</h3></div><div class="el-p"><p dir="auto">A classe Trie é o maestro da orquestra, ela coordena e controla todos os métodos para formar a estrutura, se formos encaixar na metafora do quebra-cabeça, a Trie é quem o monta. Ela conta apenas com um único atributo estático nomeado "root", que não corresponde à caractere algum. </p></div><div class="el-p"><p dir="auto">Todos os nós partem do root.</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Veja abaixo a parte inicial do código da classe Trie:</li>
</ul></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">{</span>

  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> root<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token class-name">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h2"><h2 data-heading="4.2 Operações" dir="auto" class="heading" id="4.2_Operações_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>4.2 Operações</h2></div><div class="el-p"><p dir="auto">A maioria dos métodos que veremos são bem intuitivos e nada complexos de serem compreendidos, vamos à leitura.</p></div><div class="el-h3"><h3 data-heading="4.2.1 Inserção" dir="auto" class="heading" id="4.2.1_Inserção_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>4.2.1 Inserção</h3></div><div class="el-p"><p dir="auto">A inserção de uma palavra na Trie, ocorre caractere por caractere. onde no fim, o nó que representa a última letra da palavra terá seu atributo "endWord" setado como true.</p></div><div class="el-p"><p dir="auto"><strong>Vamos exemplificar com a adição da palavra "Material":</strong></p></div><div class="el-p"><p dir="auto">A ideia é iterar sobre a palavra de tal forma que adicionemos letra por letra.</p></div><div class="el-p"><p dir="auto">Primeiro, criamos um nó auxiliar partindo do nó root (Node nodeAux). Como sabemos, cada nó tem um HashMap com as letras que partem dele. Dado isso, verificamos se no HashMap de nodeAux, com sua chave sendo a primeira letra da palavra, (m), o valor resultante é um nó ou não. Caso o valor retornado seja null, isso significa que, já que estamos partindo do root, não há nenhuma palavra que inicie com a letra m na estrutura, pois não há um nó no valor afiliado à ela. Sendo assim, temos que criar um novo nó e associá-lo. Desta forma, agora temos um nó representando aquele caractere no root.</p></div><div class="el-p"><p dir="auto">Para exemplificar melhor, vamos à um universo paralelo onde a palavra "Marca" já foi adicionada e queremos adicionar "Material". Ao iniciar do root, veremos que em seu HashMap, a chave "m" resulta em um nó, que por sua vez, em seu HashMap, a chave "a" retorna um nó, mas que agora, por sua vez, a chave "t" retorna um valor null, diferente se se verificarmos a chave "r" da palavra "Marca". Portanto, seria necessário instanciar um novo nó e adicioná-lo ao valor da chave "t".</p></div><div class="el-p"><p dir="auto">Voltando ao nosso universo canônico, temos a atualização de nodeAux. Como verificamos se a primeira letra "existia" na estrutura, e caso ainda não existisse, adicionamos-a, nodeAux agora será o nó que representa a primeira letra, e agora vamos verificar a existência de um nó que represente a segunda, (a). Veja que é como se tivéssemos dado 1 passo de nó para nó. Estávamos em root, e agora pulamos para o nó da primeira letra. A partir de agora, o processo se repete, verificando se a próxima letra como chave tem algum nó filho instanciado no HashMap do nó atual, se sim, apenas é dado um nodeAux = son, caso contrário, como visto antes, o nó é criado e associado à letra.</p></div><div class="el-p"><p dir="auto">Nossa última etapa ocorre após a verificação e adição da última letra, pois estando com ela nas mãos, temos que setar como true o atributo de seu nó que indica que ela é o fim de uma palavra. Após isso, a adição foi concluída com sucesso. </p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Para melhor compreensão, segue a implementação do método:</li>
</ul></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded"> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    word <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Node</span> nodeAux <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Node</span> son <span class="token operator">=</span> nodeAux<span class="token punctuation">.</span><span class="token function">getSons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>son <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nodeAux <span class="token operator">=</span> son<span class="token punctuation">;</span>

      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nodeAux<span class="token punctuation">.</span><span class="token function">getSons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        nodeAux <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    nodeAux<span class="token punctuation">.</span><span class="token function">setEndOfWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h3"><h3 data-heading="4.2.2 Pesquisa" dir="auto" class="heading" id="4.2.2_Pesquisa_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>4.2.2 Pesquisa</h3></div><div class="el-p"><p dir="auto">O método de pesquisa tem como parâmetro a palavra a ser pesquisada na árvore e retorna um valor booleano baseado na pergunta "A palavra está na árvore?"</p></div><div class="el-p"><p dir="auto">Assim como em todos os métodos, partimos do nó root, só que diferente da adição, nossas ações baseadas nas verificações são mais simples.</p></div><div class="el-p"><p dir="auto">Da mesma forma que o método da inserção de palavras, temos que analisar se no HashMap do nó atual, temos uma referência associada à chave da próxima letra, um nó, ou se temos o valor null. </p></div><div class="el-p"><p dir="auto">Caso o retorno da chave seja null, isto indica que não temos um nó referenciando a letra que estamos verificando na vez, portanto, ela nunca foi adicionada. Neste momento, podemos e devemos retornar o valor <strong>false</strong> para o método, indicando que a palavra não está na estrutura.</p></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    word <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Node</span> nodeAux <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Node</span> son <span class="token operator">=</span> nodeAux<span class="token punctuation">.</span><span class="token function">getSons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>son <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Caso contrário, ou seja, o valor de retorno seja um nó, passamos a verificar seu HashMap à procura da próxima letra, e assim em diante.</p></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded">      nodeAux <span class="token operator">=</span> son<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Daí pode-se pensar que é basicamente isso, dado que caso todas as letras estejam presentes na estrutura obviamente a palavra inteira está presente. Porém, vamos a um exemplo prático:</p></div><div class="el-p"><p dir="auto"><strong>Supomos que adicionamos a palavra "Carrossel" e pesquisamos a existência de "Carro":</strong></p></div><div class="el-p"><p dir="auto">ROOT -&gt; C -&gt; A -&gt; R -&gt; R -&gt; O -&gt; S -&gt; S -&gt; E -&gt; <b>L</b></p></div><div class="el-blockquote"><blockquote dir="auto">
<p>Podemos visualizar através da explicação do material, que a partir do nó root, será validada a existência da letra "c", logo após, em seu nó, a existência da letra "a", e assim em diante até chegarmos na verificação da existência da letra "o". Acabou, né? Confirmamos que a palavra "Carro" está presente e podemos retornar <strong>true</strong>...</p>
</blockquote></div><div class="el-blockquote"><blockquote dir="auto">
<p>É isso que a estrutura apresentada indica, mas nós nunca digitamos o comando add("Carro"), correto? Para isso, utilizamos o atributo que já foi mencionado no material anteriormente, que indica se certa letra representa o fim de uma palavra.<br>
Isso seria, obviamente, testado na última letra da palavra pesquisada, no nosso caso, o "o", retornando o valor booleano <strong>false</strong>.</p>
</blockquote></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded">    <span class="token keyword">return</span> nodeAux<span class="token punctuation">.</span><span class="token function">isEndOfWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Para melhor compreensão, segue a implementação completa do método:</li>
</ul></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    word <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Node</span> nodeAux <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Node</span> son <span class="token operator">=</span> nodeAux<span class="token punctuation">.</span><span class="token function">getSons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>son <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

      nodeAux <span class="token operator">=</span> son<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> nodeAux<span class="token punctuation">.</span><span class="token function">isEndOfWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h3"><h3 data-heading="4.2.3 Prefixos" dir="auto" class="heading" id="4.2.3_Prefixos_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>4.2.3 Prefixos</h3></div><div class="el-p"><p dir="auto">A jornada que o método que pesquisa por um prefixo percorre é idêntica ao search que vimos anteriormente, alterando apenas 1 detalhe que simplifica o código. Ou seja, se você sabe implementar o search(), sabe implementar o startsWith(). </p></div><div class="el-p"><p dir="auto">O método recebe como parâmetro um prefixo e retornará um valor booleano referente à existência de qualquer palavra que contenha aquele prefixo.</p></div><div class="el-p"><p dir="auto">Assim como no search(), o startsWith() percorrerá letra por letra da palavra verificando se ela existe no mapa de seu nó parent, caso a letra não tenha valor referente, o retorno é <strong>false</strong>, caso contrário chegamos no ponto que o diferencia do search().</p></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    prefix <span class="token operator">=</span> prefix<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Node</span> nodeAux <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prefix<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Node</span> son <span class="token operator">=</span> nodeAux<span class="token punctuation">.</span><span class="token function">getSons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>son <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Ao chegar na última letra, como estamos tratando de prefixos e não de palavras completas, é irrelevante a verificação isEndOfWord() do nó, portanto, se ao longo do loop o caminho não quebrar e chegar ao fim, apenas retornamos <strong>true</strong>.</p></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded">    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Segue a implementação completa:</li>
</ul></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    prefix <span class="token operator">=</span> prefix<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Node</span> nodeAux <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prefix<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Node</span> son <span class="token operator">=</span> nodeAux<span class="token punctuation">.</span><span class="token function">getSons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>son <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

      nodeAux <span class="token operator">=</span> son<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h3"><h3 data-heading="4.2.4 Remoção" dir="auto" class="heading" id="4.2.4_Remoção_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>4.2.4 Remoção</h3></div><div class="el-p"><p dir="auto">O método da remoção de uma palavra da Trie segue uma sequência de fatos e conta com 2 partes em sua remoção: </p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><strong>Remoção lógica:</strong> Desliga o atributo endWord do nó referente a última letra da palavra</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><strong>Remoção física:</strong> Através de uma verificação consegue saber quando está autorizado a remover completamente a referência ao caractere.</li>
</ul></div><div class="el-p"><p dir="auto">Veremos com mais detalhes os momentos onde as duas partes ocorrem a seguir, mas antes temos que nos inserir nos passos do método de remoção em ordem cronológica.</p></div><div class="el-p"><p dir="auto"><strong>Parte 1: Descida</strong></p></div><div class="el-p"><p dir="auto">Inicialmente, temos que descer até o último caractere da palavra, mas, diferente da forma que iteramos por ela até agora, desta vez faremos esse passo recursivamente.</p></div><div class="el-p"><p dir="auto">Chamaremos nosso método privado recursivo com 3 parâmetros:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>A palavra a ser removida</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>O nó atual</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Índice atual</li>
</ul></div><div class="el-p"><p dir="auto">Sendo os 2 útimos primeiramente:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>this.root</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>0</li>
</ul></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    word <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">remove</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">Nosso algoritmo, enquanto descemos, se baseará em pegar o nó referente a letra atual que estamos tratando e chamar recursivamente. Apenas isso. Simples, não é? Só precisamos substituir nos parâmetros o nó anterior pelo atual e incrementar no index.</p></div><div class="el-p"><p dir="auto"><strong>Parte 2: Remoção lógica</strong></p></div><div class="el-p"><p dir="auto">Ao chamarmos o método recursivamente suficiente até o index na qual estamos ser igual ao tamanho da nossa palavra - 1, o que significa que estamos no nó da última letra, aplicamos a remoção lógica, que pode ser traduzida para a desativação do atributo de finalização de palavra do nó e retornamos a função com um valor booleano, que nos informa se o mapa dos filhos do nó é vazio, o que nos levará à nossa outra remoção.</p></div><div class="el-p"><p dir="auto"><strong>Parte 3: Subida e remoção física:</strong></p></div><div class="el-p"><p dir="auto">Para subir de volta na árvore utilizaremos a parte dos retornos da função de remoção. </p></div><div class="el-p"><p dir="auto">Cada retorno da função é armazenado em um atributo booleano, que como dito antes, é baseado no fato do mapa de filhos do nó ser vazio ou não. Isso serve para nos indicar se o nó pai tem autorização de remover fisicamente o nó filho de seu mapa, o que não pode acontecer caso o filho tenha alguém referenciado no seu mapa de filhos para não quebrar a construção da árvore.</p></div><div class="el-p"><p dir="auto">Caso o retorno tenha sido <strong>true</strong>, o nó remove de seu mapa o valor da chave atual, e após essa verificação, já que a partir de agora não temos certeza se estamos em um nó que é considerado fim de uma palavra, temos que retornar o valor booleano baseado em 2 coisas:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>O mapa do nó é vazio</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Ele não é fim de uma palavra</li>
</ul></div><div class="el-p"><p dir="auto">A partir desse retorno podemos com segurança avisar ao nó pai se ele pode remover fisicamente seu filho ou não.</p></div><div class="el-p"><p dir="auto">Com esses passos subimos a árvore até terminar nossa pilha de execução, finalizando a função do método.</p></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">,</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> son <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">getSons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>son <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      son<span class="token punctuation">.</span><span class="token function">turnOffEndOfWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> son<span class="token punctuation">.</span><span class="token function">getSons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">boolean</span> canRemove <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> son<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>canRemove<span class="token punctuation">)</span> node<span class="token punctuation">.</span><span class="token function">getSons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> node<span class="token punctuation">.</span><span class="token function">getSons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>node<span class="token punctuation">.</span><span class="token function">isEndOfWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h2"><h2 data-heading="4.3 Listagem de palavras por prefixos" dir="auto" class="heading" id="4.3_Listagem_de_palavras_por_prefixos_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>4.3 Listagem de palavras por prefixos</h2></div><div class="el-p"><p dir="auto">A função deste método é nos retornar uma lista com todas as palavras que iniciam com o prefixo passado como parâmetro.</p></div><div class="el-p"><p dir="auto">Assim como o método de remoção, trabalhamos com etapas para a realização do método:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Descida até o fim do prefixo</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Adição de palavras através de DFS</li>
</ul></div><div class="el-p"><p dir="auto"><strong>Parte 1: Descida</strong></p></div><div class="el-p"><p dir="auto">Trivialmente, desceremos por iteração na árvore até o nó da última letra do prefixo, quebrando a execução e retornando uma lista vazia caso um nó não exista.</p></div><div class="el-p"><p dir="auto">Ao chegarmos no fim, chamaremos nossa função auxiliar que será responsável por montar todas as palavras e adicioná-las na lista que será retornada ao fim do processo através da técnica Depth-First Search (DFS), que percorre uma árvore por profundidade.</p></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded"><span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">findWordWithPrefix</span><span class="token punctuation">(</span><span class="token class-name">String</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    prefix <span class="token operator">=</span> prefix<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Node</span> nodeAux <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prefix<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Node</span> son <span class="token operator">=</span> nodeAux<span class="token punctuation">.</span><span class="token function">getSons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>son <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> words<span class="token punctuation">;</span>

      nodeAux <span class="token operator">=</span> son<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">catchWords</span><span class="token punctuation">(</span>nodeAux<span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> words<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><strong>Parte 2: Depth-First Search</strong></p></div><div class="el-p"><p dir="auto">A partir do nó da última letra do prefixo, chamamos a função catchWords() que terá 3 parâmetros:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>O nó atual</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>O prefixo atual</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>A lista de palavras</li>
</ul></div><div class="el-p"><p dir="auto">A cada chamada do método recursivo, sua primeira verificação é se o nó de seu parâmetro é o fim de uma palavra, pois caso seja, o prefixo se trata de uma palavra completa e é adicionado à lista final.</p></div><div class="el-p"><p dir="auto">Após a verificação inicial, utilizamos o DFS para percorrer cada ramo da árvore em profundidade concatenando os caracteres e chamando a função recursivamente. No fim do processo, a lista é retornada e temos, por fim, o resultado esperado</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Para melhor compreensão, segue a implementação do método privado:</li>
</ul></div><div class="el-pre"><pre class="language-java"><code data-line="0" class="language-java is-loaded"><span class="token keyword">private</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">catchWords</span><span class="token punctuation">(</span><span class="token class-name">Node</span> currentNode<span class="token punctuation">,</span> <span class="token class-name">String</span> currentPrefix<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> currentWords<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span><span class="token function">isEndOfWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> currentWords<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>currentPrefix<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> currentNode<span class="token punctuation">.</span><span class="token function">getSons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">String</span> nextPrefix <span class="token operator">=</span> currentPrefix <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">Node</span> nextNode <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">catchWords</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">,</span> nextPrefix<span class="token punctuation">,</span> currentWords<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> currentWords<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h2"><h2 data-heading="4.4 Análise de complexidade de tempo e memória" dir="auto" class="heading" id="4.4_Análise_de_complexidade_de_tempo_e_memória_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>4.4 Análise de complexidade de tempo e memória</h2></div><div class="el-p"><p dir="auto">E finalmente chegamos ao motivo do por que a Trie é tão importante e tão famosa nas estruturas de dados de armazenamento. Sua extrema eficiência.</p></div><div class="el-p"><p dir="auto">Pode-se pensar que para guardar, utilizando nossa implementação de exemplo, palavras, poderíamos simplesmente colocar todas em uma lista, e caso queiramos alguma, basta fazer uma iteração sobre ela, algo bem básico e cotidiano na programação. Mas em termos de eficiência, em uma escala mais profissional, isso seria muito custoso, dado que teríamos milhões de dados cadastrados, sendo assim em seu pior caso, O(n) | n = tamanho da lista.</p></div><div class="el-p"><p dir="auto">A Trie vem pra contornar esse problema de uma forma bem curiosa... Reaproveitando elementos que já estão presentes na estrutura. A essa altura da leitura deste material você já deve ter se dado conta disso (e achado bem interessante). </p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><strong>Exemplo:</strong></li>
</ul></div><div class="el-blockquote"><blockquote dir="auto">
<p>Ao adicionarmos a palavra "Cama" na estrutura e logo após, "Camaleão" e "Camada", o prefixo "Cama" é reaproveitado, assim, fazendo parte de 3 palavras diferentes!</p>
</blockquote></div><div class="el-div"><div align="center">
 <img height="500" src="assets/operacoes_listagem_exemplo_cama.png" referrerpolicy="no-referrer" target="_self">
</div>
Este reaproveitamento é a chave para a economia de memória e a performance da Trie.</div><div class="el-p"><p dir="auto">Por conseguinte, os métodos de inserção, pesquisa de palavras, pesquisa por prefixos e remoção, são em seu pior caso, O(k) | k = tamanho da palavra passada como parâmetro, sendo extremamente eficiente.</p></div><div class="el-p"><p dir="auto">O único método que se diferencia dessa regra é o de listagem das palavras a partir de certo prefixo, sendo em seu pior caso O(p + n) | p = o tamanho do prefixo ∧ n = a soma de todos os nós existentes a partir do prefixo.</p></div><div class="el-h1"><h1 data-heading="5 Comparações" dir="auto" class="heading" id="5_Comparações_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>5 Comparações</h1></div><div class="el-h2"><h2 data-heading="5.1 Trie x Hashtable" dir="auto" class="heading" id="5.1_Trie_x_Hashtable_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>5.1 Trie x Hashtable</h2></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">Critério</th>
<th dir="ltr"><strong>Trie</strong></th>
<th dir="ltr"><strong>Hash Table</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr"><strong>Conceito</strong></td>
<td dir="ltr">Árvore de prefixos em que cada nó representa um caractere da chave, caminhos formam as palavras.</td>
<td dir="ltr">Estrutura baseada em <em>funções de hash</em> que mapeia chave -&gt; valor em um array.</td>
</tr>
<tr>
<td dir="ltr"><strong>Complexidade de Busca</strong></td>
<td dir="ltr"><strong>O(L)</strong>, onde <em>L</em> é o tamanho da chave. Independente do número de chaves (n).</td>
<td dir="ltr"><strong>O(1)</strong> em média, <strong>O(n)</strong> no pior caso (muitas colisões).</td>
</tr>
<tr>
<td dir="ltr"><strong>Complexidade de Inserção</strong></td>
<td dir="ltr"><strong>O(L)</strong></td>
<td dir="ltr"><strong>O(1)</strong> em média, <strong>O(n)</strong> no pior caso.</td>
</tr>
<tr>
<td dir="ltr"><strong>Complexidade de Remoção</strong></td>
<td dir="ltr"><strong>O(L)</strong> (precisa checar se nós podem ser apagados).</td>
<td dir="ltr"><strong>O(1)</strong> em média; <strong>O(n)</strong> no pior caso.</td>
</tr>
<tr>
<td dir="ltr"><strong>Uso de Memória</strong></td>
<td dir="ltr">Geralmente <strong>maior</strong>, pois cada nó guarda ponteiros para o alfabeto.</td>
<td dir="ltr">Geralmente <strong>menor</strong>, já que cada chave é armazenada integralmente sem prefixos compartilhados.</td>
</tr>
<tr>
<td dir="ltr"><strong>Compartilhamento de Prefixos</strong></td>
<td dir="ltr"><strong>Sim</strong>, prefixos comuns são armazenados uma única vez.</td>
<td dir="ltr"><strong>Não</strong>, cada chave é guardada inteira.</td>
</tr>
<tr>
<td dir="ltr"><strong>Busca por Prefixo</strong></td>
<td dir="ltr"><strong>Excelente</strong>, encontra rapidamente todas as chaves com determinado prefixo.</td>
<td dir="ltr"><strong>Ruim</strong>, é necessário percorrer e filtrar todas as chaves.</td>
</tr>
<tr>
<td dir="ltr"><strong>Ordenação de Chaves</strong></td>
<td dir="ltr"><strong>Natural</strong>, basta percorrer a árvore em ordem alfabética.</td>
<td dir="ltr"><strong>Não existe</strong>, é preciso copiar e ordenar à parte.</td>
</tr>
<tr>
<td dir="ltr"><strong>Flexibilidade de Chaves</strong></td>
<td dir="ltr">Ideal para <strong>strings</strong> ou alfabetos finitos.</td>
<td dir="ltr">Aceita <strong>qualquer tipo de chave</strong> com função hash bem definida.</td>
</tr>
<tr>
<td dir="ltr"><strong>Dependência de Função Hash</strong></td>
<td dir="ltr"><strong>Nenhuma</strong>, não usa hashing.</td>
<td dir="ltr"><strong>Total</strong>, a qualidade da função hash é crítica para evitar colisões.</td>
</tr>
<tr>
<td dir="ltr"><strong>Escalabilidade</strong></td>
<td dir="ltr">Pode crescer muito em largura se o alfabeto for grande.</td>
<td dir="ltr">Escala bem, mas exige <em>rehash</em> quando a tabela é redimensionada.</td>
</tr>
<tr>
<td dir="ltr"><strong>Implementação</strong></td>
<td dir="ltr">Mais <strong>complexa</strong>, com múltiplos nós e ponteiros.</td>
<td dir="ltr">Mais <strong>simples</strong>, e amplamente disponível em bibliotecas padrão.</td>
</tr>
<tr>
<td dir="ltr"><strong>Melhor Cenário de Uso</strong></td>
<td dir="ltr">Autocompletar, dicionários, busca ordenada, roteamento por prefixo.</td>
<td dir="ltr">Consultas exatas e rápidas de chave→valor, cache, contadores, tabelas de símbolos.</td>
</tr>
<tr>
<td dir="ltr"><strong>Desvantagens</strong></td>
<td dir="ltr">Alto consumo de memória, custo proporcional ao tamanho da chave.</td>
<td dir="ltr">Dependência da função hash e não suporta buscas por prefixo nem ordenação natural.</td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto"><strong>Em resumo:</strong><br>
Trie: percorre cada caractere da chave, com custo O(L) (L = tamanho da chave). Compartilha prefixos, facilita busca por prefixo, autocompletar e ordenação natural das chaves. Em contrapartida, consome mais memória e é mais complexa de implementar.</p></div><div class="el-p"><p dir="auto">Hash Table: oferece buscas e inserções em O(1) em média, ideal para consultas exatas de chave -&gt; valor. Tem implementação simples e uso de memória geralmente menor, mas depende fortemente de uma boa função hash e não lida bem com prefixos ou ordenação.</p></div><div class="el-h2"><h2 data-heading="5.2 Comparação: Trie vs Árvore Balanceada" dir="auto" class="heading" id="5.2_Comparação_Trie_vs_Árvore_Balanceada_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>5.2 Comparação: Trie vs Árvore Balanceada</h2></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr"><strong>Critério</strong></th>
<th dir="ltr"><strong>Trie</strong></th>
<th dir="ltr"><strong>Árvore Balanceada (AVL, Red-Black, B-Tree etc.)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr"><strong>Estrutura</strong></td>
<td dir="ltr">Árvore em que cada <strong>nó representa um caractere</strong></td>
<td dir="ltr">Árvore binária (ou n-ária) com balanceamento baseado em <strong>comparação de chaves</strong></td>
</tr>
<tr>
<td dir="ltr"><strong>Chave</strong></td>
<td dir="ltr">Armazenada <strong>como caminho</strong> entre raiz e folha</td>
<td dir="ltr">Armazenada <strong>inteira</strong> em cada nó</td>
</tr>
<tr>
<td dir="ltr"><strong>Ordem das chaves</strong></td>
<td dir="ltr">Ordem lexicográfica natural</td>
<td dir="ltr">Ordem definida por comparações</td>
</tr>
<tr>
<td dir="ltr"><strong>Busca por prefixo</strong></td>
<td dir="ltr">Muito eficiente (O(P))</td>
<td dir="ltr">Ineficiente – requer percorrer subárvore</td>
</tr>
<tr>
<td dir="ltr"><strong>Busca por chave completa</strong></td>
<td dir="ltr">O(L) – L = comprimento da chave</td>
<td dir="ltr">O(log N) – N = número de chaves</td>
</tr>
<tr>
<td dir="ltr"><strong>Inserção</strong></td>
<td dir="ltr">O(L)</td>
<td dir="ltr">O(log N)</td>
</tr>
<tr>
<td dir="ltr"><strong>Remoção</strong></td>
<td dir="ltr">O(L)</td>
<td dir="ltr">O(log N)</td>
</tr>
<tr>
<td dir="ltr"><strong>Eficiência com prefixos</strong></td>
<td dir="ltr">Altíssima</td>
<td dir="ltr">Fraca</td>
</tr>
<tr>
<td dir="ltr"><strong>Uso de memória</strong></td>
<td dir="ltr">Maior – muitos nós (especialmente com alfabetos grandes)</td>
<td dir="ltr">Mais eficiente – armazena chaves completas</td>
</tr>
<tr>
<td dir="ltr"><strong>Comparações entre chaves</strong></td>
<td dir="ltr">Não há comparações – só navegação por caracteres</td>
<td dir="ltr">Baseada em comparação entre chaves inteiras</td>
</tr>
<tr>
<td dir="ltr"><strong>Desempenho em grandes alfabetos</strong></td>
<td dir="ltr">Pior – pode ter muitos filhos por nó</td>
<td dir="ltr">Melhor – não depende do tamanho do alfabeto</td>
</tr>
<tr>
<td dir="ltr"><strong>Autocomplete e correção</strong></td>
<td dir="ltr">Suporte direto</td>
<td dir="ltr">Precisa de lógica adicional</td>
</tr>
<tr>
<td dir="ltr"><strong>Complexidade de implementação</strong></td>
<td dir="ltr">Alta – manipulação de muitos ponteiros</td>
<td dir="ltr">Moderada – depende do tipo de árvore (AVL, Red-Black, etc.)</td>
</tr>
<tr>
<td dir="ltr"><strong>Aplicações comuns</strong></td>
<td dir="ltr">Dicionários, autocomplete, buscas por prefixo</td>
<td dir="ltr">Índices de bancos de dados, conjuntos ordenados, mapas ordenados</td>
</tr>
</tbody>
</table></div><div class="el-hr"><hr></div><div class="el-p"><p dir="auto"><strong>Em resumo:</strong><br>
A Trie busca cada caractere da chave em O(L)  (no qual L é o tamanho da chave), compartilhando prefixos e sendo ótima para autocompletar e buscas por prefixo.<br>
A BST armazena a chave inteira e busca em O(log n) (se balanceada), ideal para consultas ordenadas e intervalos, com menor consumo de memória quando não há muitos prefixos repetidos.</p></div><div class="el-h1"><h1 data-heading="6 Variações e otimizações" dir="auto" class="heading" id="6_Variações_e_otimizações_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6 Variações e otimizações</h1></div><div class="el-h2"><h2 data-heading="6.1 Radix Tree" dir="auto" class="heading" id="6.1_Radix_Tree_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.1 Radix Tree</h2></div><div class="el-h3"><h3 data-heading="6.1.1 Definição" dir="auto" class="heading" id="6.1.1_Definição_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.1.1 Definição</h3></div><div class="el-p"><p dir="auto">Uma Radix Tree (também chamada de Compact Trie ou Patrícia Tree) é uma estrutura de dados, baseada em nós, que armazena, geralmente, strings ou números de forma eficiente, especialmente quando apresentam prefixos em comum.</p></div><div class="el-p"><p dir="auto">A Radix Tree se trata de uma versão otimizada da Trie, levando-se em consideração que, na Trie, cada nó armazena apenas uma letra de uma palavra. No entanto, a Radix Tree busca armazenar prefixos de palavras, pois, assim, a estrutura se torna mais eficiente para o uso de memória, além de diminuir a quantidade de ramos existentes na árvore.</p></div><div class="el-h3"><h3 data-heading="6.1.2 Motivação" dir="auto" class="heading" id="6.1.2_Motivação_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.1.2 Motivação</h3></div><div class="el-p"><p dir="auto">A Trie armazena um apenas caractere por nó. Isso pode resultar em árvores muito grandes, principalmente quando existem palavras que utilizam prefixos semelhantes, fazendo com que a memória não seja utilizada de forma eficiente.</p></div><div class="el-p"><p dir="auto">Vejamos alguns exemplos:</p></div><div class="el-p"><p dir="auto">Armazenar carro e carroça em uma Trie:</p></div><div class="el-div"><div align="center">
 <img height="400" src="assets/saccicinct_trie_motivation_example.png" referrerpolicy="no-referrer" target="_self">
</div></div><div class="el-p"><p dir="auto">Vejamos que, na trie cada letra é armazenada em apenas um nó e que foram utilizados diversos nós para armazenar palavras com um prefixo equivalente (carro), no entanto, nesse cenário a Trie utiliza a memória para guardar dados de maneira ineficiente, quando comparamos a uma Radix Tree. </p></div><div class="el-p"><p dir="auto">Vejamos agora a inserção em uma Radix Tree:</p></div><div class="el-div"><div align="center">
 <img height="400" src="assets/radix_tree_exemplo.png" referrerpolicy="no-referrer" target="_self">
</div>
Em vez de criar um nó para armazenar cada caractere, a estrutura armazena blocos de caracteres (prefixos) em nós: carro &gt; ça.</div><div class="el-p"><p dir="auto">Assim, é perceptível que:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Prefixos comuns são compartilhados;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Nós com um único filho são combinados em substrings (prefixos);</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Fins de palavras são marcados mesmo que o caminho ainda continue (ex: “carro” termina, mas ainda existe “carroça”);</li>
</ul></div><div class="el-p"><p dir="auto">Isso reduz:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>O número de nós;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>A profundidade da árvore;</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>O número de comparações feitas durante busca e inserção.</li>
</ul></div><div class="el-h3"><h3 data-heading="6.1.3 Operações" dir="auto" class="heading" id="6.1.3_Operações_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.1.3 Operações</h3></div><div class="el-h4"><h4 data-heading="6.1.3.1 Inserção" dir="auto" class="heading" id="6.1.3.1_Inserção_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.1.3.1 Inserção</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Começa da raiz;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>A cada passo procura um filho que compartilha um prefixo equivalente à string a ser inserida, ou parte dela;</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Existem 3 casos de inserção:
<ul class="has-list-bullet">
<li data-line="3" dir="auto"><span class="list-bullet"></span><strong>Sem prefixo em comum</strong>: Nesse caso a string é adicionada em um novo nó;</li>
<li data-line="4" dir="auto"><span class="list-bullet"></span><strong>Prefixo completo do filho</strong>: Csse é o caso de “carro” e “carroça”, ao adicionar “carroça”, é adicionado um novo nó, filho de “carro” que contém o prefixo “ça”;</li>
<li data-line="5" dir="auto"><span class="list-bullet"></span><strong>Prefixo parcial</strong>: Precisa dividir (split) o nó existente.</li>
</ul>
</li>
</ul></div><div class="el-p"><p dir="auto"><strong>Vejamos um exemplo do caso 3. para adicionar “rápido” em uma árvore que contém “raiz”:</strong></p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Prefixo em comum: “ra”;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Resto de “raiz”: “iz”;</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Resto de “rápido”: “pido”;</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Criação de um novo nó “ra” que terá dois filhos:
<ul class="has-list-bullet">
<li data-line="4" dir="auto"><span class="list-bullet"></span>“iz” (marcado como fim de “raiz”);</li>
<li data-line="5" dir="auto"><span class="list-bullet"></span>“pido” (marcado como fim de “rápido”);</li>
</ul>
</li>
</ul></div><div class="el-hr"><hr></div><div class="el-h4"><h4 data-heading="6.1.3.2 Busca" dir="auto" class="heading" id="6.1.3.2_Busca_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.1.3.2 Busca</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Começa da raiz;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Busca um filho com prefixo equivalente;</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Caso encontre:
<ul class="has-list-bullet">
<li data-line="3" dir="auto"><span class="list-bullet"></span>Desmarca aquele prefixo como fim de uma palavra;</li>
<li data-line="4" dir="auto"><span class="list-bullet"></span>Continua a busca no filho;</li>
</ul>
</li>
<li data-line="5" dir="auto"><span class="list-bullet"></span><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Caso contrário:
<ul class="has-list-bullet">
<li data-line="6" dir="auto"><span class="list-bullet"></span>Retorna false, pois não está na árvore;</li>
</ul>
</li>
<li data-line="7" dir="auto"><span class="list-bullet"></span><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Verificamos se o nó atual é o fim de uma palavra:
<ul class="has-list-bullet">
<li data-line="8" dir="auto"><span class="list-bullet"></span>Se for, palavra encontrada → retorna <code>true</code>;</li>
</ul>
</li>
</ul></div><div class="el-hr"><hr></div><div class="el-h4"><h4 data-heading="6.1.3.3 Remoção" dir="auto" class="heading" id="6.1.3.3_Remoção_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.1.3.3 Remoção</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Busca a palavra;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Se encontrar, desmarca ele como o fim de uma palavra;</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Verificamos se os nós podem ser removidos ou unidos:
<ul class="has-list-bullet">
<li data-line="3" dir="auto"><span class="list-bullet"></span>Se o nó <strong>não tem filhos</strong> e <strong>não é o fim de outra palavra</strong>, pode ser <strong>removido</strong>;</li>
<li data-line="4" dir="auto"><span class="list-bullet"></span>Se o nó <strong>tem um filho</strong> e <strong>não é o fim de uma palavra</strong>, pode ser <strong>unido (concatenado)</strong>.</li>
</ul>
</li>
</ul></div><div class="el-h3"><h3 data-heading="6.1.4 Complexidade" dir="auto" class="heading" id="6.1.4_Complexidade_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.1.4 Complexidade</h3></div><div class="el-p"><p dir="auto">A Radix Tree possui complexidade O(k), de modo que k significa o tamanho da palavra, para inserção, remoção e busca. É mais eficiente que a Trie por reduzir o número de nós.</p></div><div class="el-h2"><h2 data-heading="6.2 Succinct Trie" dir="auto" class="heading" id="6.2_Succinct_Trie_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.2 Succinct Trie</h2></div><div class="el-h3"><h3 data-heading="6.2.1 Definição" dir="auto" class="heading" id="6.2.1_Definição_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.2.1 Definição</h3></div><div class="el-p"><p dir="auto">  Uma Succinct Trie é uma estrutura de dados que representa uma Trie tradicional de maneira compacta, buscando ocupar o menor espaço possível de memória, mantendo também a capacidade de realizar as demais operações, busca e navegação com eficiência. Assim, essa estrutura é ideal para armazenar grandes volumes de dados imutáveis com prefixos equivalentes, já que a inserção e remoção é custosa, como em dicionários, sistemas embarcados e etc.</p></div><div class="el-p"><p dir="auto">  A grande diferença entre a Succinct Trie e a Trie tradicional, se diz respeito à forma como os dados são armazenados na memória, pois ao invés de usar ponteiros para referenciar caracteres, são utilizadas estruturas bit-level compactadas. Bit-level compactadas são estruturas que utilizam bits individuais, para representar objetos na memória de forma mais eficiente em espaço e garantir a utilização da memória de maneira mais eficiente possível.</p></div><div class="el-p"><p dir="auto">Essa estrutura é formada por:  LOUDS — Level-Order Unary Degree Sequence, Label Array e terminal bitmap. </p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><strong>Louds</strong> nada mais é do que a codificação, em bits, da quantidade de filho de cada nó;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><strong>Label array</strong> é um vetor paralelo que armazena os caracteres associados a cada, respectivo nó, mantendo a ordem BFS dos nós;</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><strong>Terminal bitmaps</strong> são vetores que indicam se os nós de um determinado nível são fins de palavra ou não, também representados em bits (<code>1</code> para fim e <code>0</code> caso não seja fim).</li>
</ul></div><div class="el-h3"><h3 data-heading="6.2.2 Motivação" dir="auto" class="heading" id="6.2.2_Motivação_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.2.2 Motivação</h3></div><div class="el-p"><p dir="auto">  Como já foi discutido, as Tries tradicionais utilizam a memória de maneira ineficiente quando a comparamos com suas otimizações. Quando vamos utilizar uma trie para armazenar um grande número de dados, em que a memória é crítica e os dados são majoritariamente utilizados para leitura, podemos encontrar um problema em relação ao espaço de memória que está sendo utilizado, por isso, nesse cenário, as Succinct Tries utilizam a memória de maneira mais eficiente, pois consegue armazenar elementos (prefixos) utilizando a estratégia de bit-levels compactadas, preservando e otimizando a capacidade de busca e navegação, reduzindo drasticamente o uso de memória. </p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>
<p>Vejamos um exemplo:<br>
Armazenar as palavras “carro” e “carroça” em uma Trie tradicional:</p>
<div align="center">
 <img height="400" src="assets/saccicinct_trie_motivation_example.png" referrerpolicy="no-referrer" target="_self">
</div>
<p>  Vejamos que, a trie tradicional armazena cada letra em apenas um nó fazendo com que sejam utilizados vários nós para representar a palavra “carro” e “carroça”, vejamos agora a representação dessas mesmas palavra em uma Succinct Trie:</p>
</li>
</ul></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">Estrutura</th>
<th dir="ltr">Conteúdo</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr"><code>labels</code></td>
<td dir="ltr"><code>['c', 'a', 'r', 'r', 'o', 'ç', 'a']</code></td>
</tr>
<tr>
<td dir="ltr"><code>bit_vector</code></td>
<td dir="auto"><code>[1,0, 1,0, 1,0, 1,0, 1,0, 1,0, 0]</code></td>
</tr>
<tr>
<td dir="ltr"><code>is_terminal</code></td>
<td dir="auto"><code>[0, 0, 0, 0, 1, 0, 1]</code></td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto">  Assim, vemos que a Succinct Trie representa dados de maneira mais eficiente, de modo que todos os nós, seguindo a BFS são armazenados em um vetor (labels), bem como o bit_vector armazena a quantidade de filhos de cada “nó”, em formato de bits e is_terminal representa quais “nós” são finais ou não de palavras.</p></div><div class="el-h3"><h3 data-heading="6.2.3 Complexidade" dir="auto" class="heading" id="6.2.3_Complexidade_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.2.3 Complexidade</h3></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">Tipo</th>
<th dir="ltr">Custo</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr">Espaço</td>
<td dir="ltr"><code>2n + n × log(σ) + o(n)</code> bits</td>
</tr>
<tr>
<td dir="ltr">Busca</td>
<td dir="ltr"><code>O(k)</code></td>
</tr>
<tr>
<td dir="ltr">Navegação</td>
<td dir="ltr"><code>O(1)</code> ou <code>O(log n)</code></td>
</tr>
<tr>
<td dir="ltr">Inserção</td>
<td dir="ltr">Muito alto</td>
</tr>
<tr>
<td dir="ltr">Remoção</td>
<td dir="ltr">Muito alto</td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto">  Dessa forma, a utilização das Succinct Tries se torna bem mais eficiente para armazenar muitos dados em que são imutáveis, sendo utilizados para buscas ou navegação, ex: dicionários.</p></div><div class="el-h2"><h2 data-heading="6.3 Concurrent Tries" dir="auto" class="heading" id="6.3_Concurrent_Tries_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.3 Concurrent Tries</h2></div><div class="el-h3"><h3 data-heading="6.3.1 Definição" dir="auto" class="heading" id="6.3.1_Definição_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.3.1 Definição</h3></div><div class="el-p"><p dir="auto">  Concurrent Tries é uma estrutura de dados que, como as outras, também é baseada em árvores e tende a ser uma versão otimizada de uma trie convencional, por utilizar técnicas de lock, além de utilizarem hash’s como estrutura auxiliar. No entanto, ela suporta acesso simultâneo seguro por múltiplas threads sem corromper a estrutura e sem retornar resultados inconsistentes, ou seja, permitem leitura e escrita concorrente, bem como evitam locks globais e minimizam contenção entre threads.</p></div><div class="el-p"><p dir="auto">Uma Ctrie é estruturada como uma árvore de prefixos, de modo que: </p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Cada nó representa um <strong>prefixo</strong>  </li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Cada nível da árvore corresponde a uma <strong>parte do prefixo (caractere)</strong>  </li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Os nós podem conter:
<ul class="has-list-bullet">
<li data-line="3" dir="auto"><span class="list-bullet"></span>um <strong>mapa de filhos</strong>, que associa cada prefixo aos próximos nós  </li>
<li data-line="4" dir="auto"><span class="list-bullet"></span>e um <strong>valor</strong> (caso represente uma chave completa)  </li>
</ul>
</li>
<li data-line="5" dir="auto"><span class="list-bullet"></span>Permite <strong>snapshotting eficiente</strong>, ou seja, tirar uma cópia consistente do trie <strong>sem travar a estrutura</strong></li>
</ul></div><div class="el-h3"><h3 data-heading="6.3.2 Motivação" dir="auto" class="heading" id="6.3.2_Motivação_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.3.2 Motivação</h3></div><div class="el-p"><p dir="auto">  As Ctries possuem grande usabilidade na computação, principalmente em áreas de roteamento de IP, interpretação de linguagens, caches em tempo real, Servidores HTTP ou REST com alta concorrência e etc. Isso acontece pois nas Ctries vários usuários podem fazer a mesma operação ao mesmo tempo que não vai haver a perca ou sobrescrição de dados, isso ocorre pois essa estrutura utiliza de técnicas avançadas para inserção, remoção e busca, vejamos:</p></div><div class="el-h3"><h3 data-heading="6.3.3 Lock-Based Tries" dir="auto" class="heading" id="6.3.3_Lock-Based_Tries_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.3.3 Lock-Based Tries</h3></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Usa <strong>locks finos</strong> em cada nó para permitir múltiplas operações paralelas, ou seja, em vez de travar a estrutura toda para fazer uma operação, você trava apenas a menor parte necessária  </li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Conforme aumenta o número de threads, melhor a estrutura funciona  </li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Reduz a chance de threads ficarem esperando  </li>
</ul></div><div class="el-hr"><hr></div><div class="el-h3"><h3 data-heading="6.3.4 Lock-Free Tries" dir="auto" class="heading" id="6.3.4_Lock-Free_Tries_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.3.4 Lock-Free Tries</h3></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Usa <strong>instruções atômicas</strong>, como o <strong>CAS</strong>, pois evita deadlock, contenção e se torna mais seguro por ser feito em hardware  </li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Evita completamente locks, mas é mais difícil de implementar  </li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Melhor performance sob alta concorrência  </li>
</ul></div><div class="el-hr"><hr></div><div class="el-h3"><h3 data-heading="6.3.5 Immutable Tries" dir="auto" class="heading" id="6.3.5_Immutable_Tries_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.3.5 Immutable Tries</h3></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Cada modificação cria uma <strong>nova versão</strong> da estrutura  </li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Threads podem acessar <strong>versões antigas com segurança</strong>, pois os nós são imutáveis  </li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Não destroem o estado anterior de um nó  </li>
</ul></div><div class="el-h3"><h3 data-heading="6.3.6 Operações" dir="auto" class="heading" id="6.3.6_Operações_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.3.6 Operações</h3></div><div class="el-h4"><h4 data-heading="6.3.6.1 Inserção" dir="auto" class="heading" id="6.3.6.1_Inserção_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.3.6.1 Inserção</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Percorre os nós até onde a chave diverge ou termina  </li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Cria novos nós se necessário  </li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Em Ctries (hash tries), percorre a árvore inspecionando blocos de bits do hash  </li>
</ul></div><div class="el-hr"><hr></div><div class="el-h4"><h4 data-heading="6.3.6.2 Busca" dir="auto" class="heading" id="6.3.6.2_Busca_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.3.6.2 Busca</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Caminha até o final da chave  </li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Se a estrutura for bem balanceada e não houver colisões (no hash), a profundidade é limitada  </li>
</ul></div><div class="el-hr"><hr></div><div class="el-h4"><h4 data-heading="6.3.6.3 Remoção" dir="auto" class="heading" id="6.3.6.3_Remoção_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.3.6.3 Remoção</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Encontra o nó da chave  </li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Marca como removido  </li>
</ul></div><div class="el-hr"><hr></div><div class="el-h4"><h4 data-heading="6.3.6.4 Snapshot" dir="auto" class="heading" id="6.3.6.4_Snapshot_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.3.6.4 Snapshot</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Apenas aponta para o nó raiz atual  </li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Como os nós são imutáveis, não há risco de inconsistência  </li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Leitores podem continuar acessando a versão antiga mesmo após novas inserções  </li>
</ul></div><div class="el-h3"><h3 data-heading="6.3.7 Complexidade" dir="auto" class="heading" id="6.3.7_Complexidade_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.3.7 Complexidade</h3></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">Operação</th>
<th dir="ltr">Complexidade Média</th>
<th dir="ltr">Pior caso</th>
<th dir="ltr">Observações</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr"><strong>Inserção</strong></td>
<td dir="ltr"><code>O(k)</code> ou <code>O(log n)</code></td>
<td dir="ltr"><code>O(k)</code></td>
<td dir="ltr">Um nó por caractere/nível; pode haver colisões</td>
</tr>
<tr>
<td dir="ltr"><strong>Busca</strong></td>
<td dir="ltr"><code>O(k)</code> ou <code>O(log n)</code></td>
<td dir="ltr"><code>O(k)</code></td>
<td dir="ltr">Caminha até a folha correspondente</td>
</tr>
<tr>
<td dir="ltr"><strong>Remoção</strong></td>
<td dir="ltr"><code>O(k)</code></td>
<td dir="ltr"><code>O(k)</code></td>
<td dir="ltr">Pode envolver limpeza de nós intermediários</td>
</tr>
<tr>
<td dir="ltr"><strong>Snapshot</strong></td>
<td dir="ltr"><code>O(1)</code></td>
<td dir="ltr"><code>O(1)</code></td>
<td dir="ltr">Apenas copia a referência do nó raiz (imutável)</td>
</tr>
</tbody>
</table></div><div class="el-h2"><h2 data-heading="6.4 BURST TRIES" dir="auto" class="heading" id="6.4_BURST_TRIES_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.4 BURST TRIES</h2></div><div class="el-h3"><h3 data-heading="6.4.1 Definição" dir="auto" class="heading" id="6.4.1_Definição_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.4.1 Definição</h3></div><div class="el-p"><p dir="auto"> Burst Tries nada mais é do que uma estrutura de dados híbrida, pois utiliza uma organização hierárquica de uma Trie convencional (árvore), mas conta também com a utilização de buffers (arrays) nas folhas para o armazenamento de um conjunto de chaves com prefixos em comum. Se trata, assim como as anteriores, de uma versão otimizada de uma Trie, que garante melhor performance e otimização do uso da memória, pois armazena múltiplas chaves por folhas (buffers). Um problema da estrutura surge quando o buffer de uma ou mais folhas, ficam totalmente preenchidos, assim é feito o chamado “burst”, que consiste em criar novos nós internos e redistribuir as chaves armazenadas com base nos próximos caracteres. Desse modo a árvore cresce sob demanda.<br>
Essa estrutura garante um grande ganho de desempenho no que se diz respeito a busca, inserção e armazenamento de grandes conjuntos de strings, pois reduz o overhead de ponteiros em tries tradicionais e melhora a localidade de cache. Vejamos cenários que apresentam boa usabilidade:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Compiladores;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Sistemas de indexação;</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Dicionários dinâmicos.</li>
</ul></div><div class="el-h3"><h3 data-heading="6.4.2 Motivação" dir="auto" class="heading" id="6.4.2_Motivação_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.4.2 Motivação</h3></div><div class="el-p"><p dir="auto">  Como já foi discutido anteriormente, as Tries tradicionais são excelentes estruturas para armazenarem dados com base em prefixos, no entanto essa estrutura possui algumas limitações ao armazenar um grande conjunto de dados, como: uso excessivo de memória, muitos ponteiros e crescimento excessivo da árvore.<br>
Desse modo, surge as Burst Tries que consegue equilibrar eficiência e praticidade, porquanto armazenam várias chaves com um mesmo prefixo em um único buffer	 e quando esse buffer atinge sua capacidade máxima, novos nós intermediários são criados e as chaves são divididas com base no próximo caractere, assim evitando a criação prematura de nós e reduzindo o consumo de memória.</p></div><div class="el-h3"><h3 data-heading="6.4.3 Operações" dir="auto" class="heading" id="6.4.3_Operações_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.4.3 Operações</h3></div><div class="el-h4"><h4 data-heading="6.4.3.1 Inserção" dir="auto" class="heading" id="6.4.3.1_Inserção_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.4.3.1 Inserção</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Busca o buffer correspondente ao prefixo;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Insere a chave no buffer;</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Se ultrapassar o limite do buffer, ocorre o burst;</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span>Cria um novo buffer;</li>
<li data-line="4" dir="auto"><span class="list-bullet"></span>Redistribui as chaves em novos nós, com base nos novos prefixos;</li>
</ul></div><div class="el-h4"><h4 data-heading="6.4.3.2 Busca" dir="auto" class="heading" id="6.4.3.2_Busca_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.4.3.2 Busca</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Caminha pela trie até o buffer correspondente;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Procura a chave dentro do buffer (usando busca binária);</li>
</ul></div><div class="el-h4"><h4 data-heading="6.4.3.3 Remoção" dir="auto" class="heading" id="6.4.3.3_Remoção_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.4.3.3 Remoção</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Encontra o buffer da chave;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Remove a chave do buffer;</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Opcionalmente remove subtries vazias;</li>
</ul></div><div class="el-h3"><h3 data-heading="6.4.4 Complexidade" dir="auto" class="heading" id="6.4.4_Complexidade_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.4.4 Complexidade</h3></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">Operação</th>
<th dir="ltr">Complexidade Média</th>
<th dir="ltr">Pior Caso</th>
<th dir="ltr">Observações</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr"><strong>Busca</strong></td>
<td dir="ltr"><code>O(k + log m)</code></td>
<td dir="ltr"><code>O(k + m)</code></td>
<td dir="ltr"><code>k</code> = tamanho da chave, <code>m</code> = tamanho do buffer</td>
</tr>
<tr>
<td dir="ltr"><strong>Inserção</strong></td>
<td dir="ltr"><code>O(k + log m)</code></td>
<td dir="ltr"><code>O(k + m)</code></td>
<td dir="ltr">Pode causar <em>burst</em> → redistribuição de <code>m</code> chaves</td>
</tr>
<tr>
<td dir="ltr"><strong>Remoção</strong></td>
<td dir="ltr"><code>O(k + log m)</code></td>
<td dir="ltr"><code>O(k + m)</code></td>
<td dir="ltr">Sem burst, só remove do buffer</td>
</tr>
<tr>
<td dir="ltr"><strong>Burst</strong></td>
<td dir="auto">—</td>
<td dir="ltr"><code>O(m)</code></td>
<td dir="ltr">Ocorre apenas quando buffer atinge o limite</td>
</tr>
</tbody>
</table></div><div class="el-h2"><h2 data-heading="6.5 Ternary Search Tries" dir="auto" class="heading" id="6.5_Ternary_Search_Tries_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.5 Ternary Search Tries</h2></div><div class="el-h3"><h3 data-heading="6.5.1 Definição" dir="auto" class="heading" id="6.5.1_Definição_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.5.1 Definição</h3></div><div class="el-p"><p dir="auto">  Uma Ternary Search Tree é uma estrutura de dados que combina as propriedades de uma Trie convencional e árvores de busca binária (BST), adaptada para armazenar strings de forma eficiente, tanto em relação ao tempo, quanto em relação ao consumo de memória. Sua estrutura é composta por um nó, que armazena um único caractere e três filhos, um à esquerda (para armazenar caracteres menores que o pai), um ao centro (para o próximo caractere da string, se o caractere atual for igual) e um à direita (para caracteres maiores que o pai). As TST’s tem grande usabilidade no dia à dia, como: sistemas de busca de autocomplete, dicionários e corretores ortográficos, compiladores e interpretadore e entre outros.<br>
Ademais, sua ideia principal é percorrer cada caractere de forma ordenada, de forma análoga à uma busca binária sobre a palavra, mas mantendo a estrutura sequencial das strings. A TST se torna mais eficiente, pois:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Nas tries, cada nó pode ter 256 filhos (seguindo a tabela ASCII), o que exige grandes hashes;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Em TST’s , cada nó possui apenas 3 ponteiros;</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Em grandes conjuntos de palavras se torna muito eficiente.</li>
</ul></div><div class="el-h3"><h3 data-heading="6.5.2 Operações" dir="auto" class="heading" id="6.5.2_Operações_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.5.2 Operações</h3></div><div class="el-h4"><h4 data-heading="6.5.2.1 Inserção" dir="auto" class="heading" id="6.5.2.1_Inserção_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.5.2.1 Inserção</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Inicia pela raiz e compara cada caractere;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Se menor, vai pra subárvore à esquerda;</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Se maior, vai pra subárvore à direita;</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span>Se igual, avança para o filho do meio.</li>
</ul></div><div class="el-h4"><h4 data-heading="6.5.2.2 Busca" dir="auto" class="heading" id="6.5.2.2_Busca_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.5.2.2 Busca</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Percorre cada caractere e faz as mesmas comparações da inserção;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>A palavra existe se o algoritmo chegar a um nó marcado como "fim de palavra".</li>
</ul></div><div class="el-h4"><h4 data-heading="6.5.2.3 Remoção" dir="auto" class="heading" id="6.5.2.3_Remoção_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.5.2.3 Remoção</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Faz uma busca da palavra a ser removida;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Caso a encontre, a marca como “removida”;</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Caso contrário, não faz nada, pois a palavra a ser removida não está lá;</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span>Opcionalmente, ramos vazios podem ser removidos.</li>
</ul></div><div class="el-h4"><h4 data-heading="6.5.2.4 Busca por prefixo" dir="auto" class="heading" id="6.5.2.4_Busca_por_prefixo_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.5.2.4 Busca por prefixo</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Percorre todo o prefixo;</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Depois, faz travessia da subárvore do meio coletando palavras.</li>
</ul></div><div class="el-h3"><h3 data-heading="6.5.3 Complexidade" dir="auto" class="heading" id="6.5.3_Complexidade_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>6.5.3 Complexidade</h3></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th dir="ltr">Operação</th>
<th dir="ltr">Complexidade (Tempo)</th>
<th dir="ltr">Observações</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="ltr"><strong>Busca</strong></td>
<td dir="ltr">O(k + h)</td>
<td dir="ltr"><code>k</code> = tamanho da string, <code>h</code> = altura da árvore</td>
</tr>
<tr>
<td dir="ltr"><strong>Inserção</strong></td>
<td dir="ltr">O(k + h)</td>
<td dir="ltr">Pode precisar criar até <code>k</code> novos nós</td>
</tr>
<tr>
<td dir="ltr"><strong>Remoção</strong></td>
<td dir="ltr">O(k + h)</td>
<td dir="ltr">Remove marca de fim de palavra; poda é opcional</td>
</tr>
<tr>
<td dir="ltr"><strong>Busca por prefixo</strong></td>
<td dir="ltr">O(k + n)</td>
<td dir="ltr"><code>n</code> = nº de palavras com o prefixo; percorre subárvore</td>
</tr>
<tr>
<td dir="ltr"><strong>Espaço (Memória)</strong></td>
<td dir="ltr">O(n·k)</td>
<td dir="ltr">Menor que trie, pois só 3 ponteiros por nó</td>
</tr>
</tbody>
</table></div><div class="el-p"><p dir="auto">  Em diversos cenários, a TST garante a praticidade e excelente performance, devido a sua compacidade dos dados e do acesso sequencial dos caracteres, bem como a comparação de prefixos ocorre ordenadamente, garantindo o melhor aproveitamento da memória. Além disso, se a árvore estiver balanceada, o custo de h = log n, assim como nas BST’s convencionais.</p></div><div class="el-h1"><h1 data-heading="7 Aplicações no mundo real" dir="auto" class="heading" id="7_Aplicações_no_mundo_real_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7 Aplicações no mundo real</h1></div><div class="el-h2"><h2 data-heading="7.1 Rede de Computadores" dir="auto" class="heading" id="7.1_Rede_de_Computadores_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.1 Rede de Computadores</h2></div><div class="el-h3"><h3 data-heading="7.1.1 Roteamento de Pacotes IP" dir="auto" class="heading" id="7.1.1_Roteamento_de_Pacotes_IP_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.1.1 Roteamento de Pacotes IP</h3></div><div class="el-p"><p dir="auto">Em redes, cada pacote IP precisa ser roteado para seu destino correto, e isso é feito com base no seu Endereço IP de destino. Para isso, os roteadores mantém uma tabela de rotas onde cada uma das entradas vai indicar qual vai ser o próximo salto para um determinado prefixo. Ou seja, quando o roteador receber um determinado pacote, ele vai precisar decidir para onde enviar esse pacote na Rede para que esse pacote chegue ao seu destino correto. Cada uma das entradas da tabela possui 2 coisas importantes, um prefixo e um próximo salto.</p></div><div class="el-p"><p dir="auto"><strong>Prefixo:</strong><br>
É a parte inicial de um endereço IP que vai representar um grupo de endereços. Vamos supor que temos um prefixo de um endereço ip com "113.237.00/16", o prefixo "113.237." vai cobrir todos os Endereços que começam com "113.237.", ou seja de "113.237.0.0", até "113.237.255.255".</p></div><div class="el-p"><p dir="auto"><strong>Próximo salto:</strong>	<br>
É a porta ou o caminho para onde deve ser enviado o pacote para que chegue ao seu destino correto. Geralmente é uma interface física, como uma conexão Ethernet, ou o endereço IP do próximo roteador na rota.</p></div><div class="el-p"><p dir="auto"><strong>Resolvendo Problemas:</strong><br>
Agora que sabemos como funciona o Roteamento de pacotes IP vamos supor o determinado problema. Dado um endereço IP "985.623.1.88", encontre a entrada de rota mais específica possível.</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Rotas:
<blockquote dir="auto">
<p>Rota 1: 985.643.2.88.</p>
<p>Rota 2: 885.623.1.88.</p>
<p>Rota 3. 985.623.00/16.</p>
</blockquote>
</li>
</ul></div><div class="el-p"><p dir="auto">Quando o pacote com o destino "985.623.1.88" chegar, o roteador vai converter esse IP em binário e vai percorrer a trie bit a bit. Durante essa busca, ele vai verificar se há alguma entrada de rota correspondente no caminho, sempre que ele encontra uma entrada válida ele armazena essa entrada como a “melhor rota até o momento”. Ele faz isso até que não seja mais possível descer na árvore pela falta de nós filhos ou porque o endereço chegou ao fim. No final a entrada armazenada vai ser a entrada que tem o prefixo mais longo, ou seja a melhor rota para aquele destino.</p></div><div class="el-h2"><h2 data-heading="7.2 Análise de Sequências de DNA" dir="auto" class="heading" id="7.2_Análise_de_Sequências_de_DNA_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.2 Análise de Sequências de DNA</h2></div><div class="el-h3"><h3 data-heading="7.2.1 Armazenamento e Busca em Grandes Volumes de Dados Genéticos" dir="auto" class="heading" id="7.2.1_Armazenamento_e_Busca_em_Grandes_Volumes_de_Dados_Genéticos_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.2.1 Armazenamento e Busca em Grandes Volumes de Dados Genéticos</h3></div><div class="el-p"><p dir="auto">Na bioinformática, pesquisadores lidam diariamente sequências de DNA. Essas sequências são compostas por quatro letras (A, C, G, T), que representam os nucleotídeos.</p></div><div class="el-p"><p dir="auto">Essas sequências são frequentemente armazenadas, comparadas e analisadas para:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Identificar padrões genéticos</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Encontrar regiões comuns entre espécies</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Detectar mutações</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span>Realizar buscas rápidas por subsequências</li>
</ul></div><div class="el-p"><p dir="auto"><strong>Agora vamos pensar:</strong></p></div><div class="el-p"><p dir="auto">Como podemos usar a Trie para resolver problemas que envolvem sequências de DNA?</p></div><div class="el-p"><p dir="auto">Pense comigo, dada um grande conjunto de sequência de DNA, como podemos armazená-las de forma eficiente? Como podemos buscar rapidamente se uma determinada sequência está nesse conjunto, ou até mesmo encontrar todas as ocorrências de uma subsequência?</p></div><div class="el-p"><p dir="auto">Bom, como já vimos anteriormente, a Trie é ideal para representar grandes conjuntos de strings com prefixos comuns, como acontece nas sequências de DNA, onde muitas compartilham trechos semelhantes. Cada nó da Trie representa um nucleotídeo, (A, C, G ou T). Cada caminho da raiz até um nó terminal representa uma sequência ou subsequência de DNA.</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Exemplo:</li>
</ul></div><div class="el-p"><p dir="auto">Suponha que queremos armazenar as seguintes sequências na nossa Trie.</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>ATCGCCGT</p>
<p>ATCAGT</p>
<p>ATTGCG</p>
<p>GCTACA</p>
<p>GCTATT</p>
</blockquote></div><div class="el-p"><p dir="auto">A Trie que será construída terá ramos em comum para os ramos que tem prefixos repetidos, como podemos observar na imagem.<br>
<br><br>
<br></p></div><div class="el-div"><div align="center">
  <img height="600" src="assets/trie_dna.png" referrerpolicy="no-referrer" target="_self">
</div>
<br>
<br>
Essas sequências genéticas podem ser muito mais longas e repetitivas que essas que utilizamos. É nesse momento que o uso da Trie se torna muito mais eficiente, pois ao ultilizar a Trie para armazenar essas sequências, o uso do armazenamento vai ser otimizado, já que quando várias sequências de DNA compartilham os mesmos prefixos, a Trie armazena esse prefixo uma única vez.
<br>
<br>
Além disso, o uso da Trie vai otimizar o tempo de busca dessas sequências, porque muitas delas compartilham prefixos, ou seja, começam com as mesmas sequências. A Trie aproveita isso, tornando assim a busca mais rápida, já que não precisa repetir o mesmo caminho várias vezes. Isso é ideal quando temos muitas sequências parecidas, como é comum no DNA, tornando assim a Trie muito utilizada para buscar sequências de DNA principalmente em áreas da bioinformática, onde é essencial lidar com grandes volumes de dados genéticos de forma rápida e eficiente.</div><div class="el-h2"><h2 data-heading="7.3 PLN - Processamento de Linguagem Natural" dir="auto" class="heading" id="7.3_PLN_-_Processamento_de_Linguagem_Natural_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.3 PLN - Processamento de Linguagem Natural</h2></div><div class="el-h3"><h3 data-heading="7.3.1 Manipulação e Análise de Texto em Grande Escala" dir="auto" class="heading" id="7.3.1_Manipulação_e_Análise_de_Texto_em_Grande_Escala_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.3.1 Manipulação e Análise de Texto em Grande Escala</h3></div><div class="el-p"><p dir="auto">No campo de PLN (Processamento de Linguagem Natural), sistemas precisam lidar com grandes volumes de texto para tarefas como:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Correção ortográfica</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Sugestão de Palavras(autocompletar)</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Busca por prefixos</li>
</ul></div><div class="el-p"><p dir="auto">Todas essas tarefas envolvem buscas rápidas por palavras ou prefixos, principalmente em grandes conjuntos de palavras.</p></div><div class="el-p"><p dir="auto"><strong>Agora pense comigo:</strong></p></div><div class="el-p"><p dir="auto">Imagine que temos um enorme dicionário de palavras com milhares de entradas. Precisamos armazenar essas palavras de forma eficiente e também permitir buscas rápidas, como:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Verificar se uma palavra está correta</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Sugerir palavras a partir de um prefixo digitado</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Encontrar todas as palavras que começam com um determinado trecho</li>
</ul></div><div class="el-p"><p dir="auto"><strong>Onde a Trie poderia nos ajudar?</strong></p></div><div class="el-p"><p dir="auto">Bom,como já sabemos A Trie é uma estrutura de dados ideal para representar grandes conjuntos de strings com prefixos em comum, que é exatamente o que acontece em muitas palavras de um idioma. Cada nó da Trie representa uma letra do alfabeto, e cada caminho da raiz até um nó terminal representa uma palavra completa.</p></div><div class="el-p"><p dir="auto">Suponha que queremos armazenar as seguintes palavras:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>casa</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>casamento  </li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>casaco</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span>caminho </li>
<li data-line="4" dir="auto"><span class="list-bullet"></span>carro  </li>
<li data-line="5" dir="auto"><span class="list-bullet"></span>carta</li>
</ul></div><div class="el-p"><p dir="auto">A Trie que será construída terá ramos em comum para os prefixos repetidos (por exemplo, "ca", "cas", "cam"), como acontece frequentemente na linguagem natural.<br>
Assim como em sequências de DNA, as palavras podem compartilhar partes idênticas no início, e a Trie aproveita isso para otimizar o armazenamento. Em vez de repetir cada letra para cada palavra, a Trie armazena os prefixos compartilhados apenas uma vez. Tendo assim um melhor uso do armazenamento e muita Eficiência na busca por palavras.</p></div><div class="el-h2"><h2 data-heading="7.4 Algoritmos de Busca e Ordenação" dir="auto" class="heading" id="7.4_Algoritmos_de_Busca_e_Ordenação_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.4 Algoritmos de Busca e Ordenação</h2></div><div class="el-h3"><h3 data-heading="7.4.1 Algoritmo de Aho-Corasick" dir="auto" class="heading" id="7.4.1_Algoritmo_de_Aho-Corasick_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.4.1 Algoritmo de Aho-Corasick</h3></div><div class="el-p"><p dir="auto">O algoritmo Aho-Corasick é um algoritmo de busca de strings criado em 1975 por Alfred V. Aho e Margaret J. Corasick. Ele é um algoritmo que nos permite localizar ocorrências de múltiplas strings (0 dicionário") dentro de um texto de entrada. O algoritmo realiza a busca por todas as strings ao mesmo tempo, tornando-se eficiente para essa tarefa. Sua complexidade é paralela ao tamanho das strings do dicionário somado ao comprimento do texto pesquisado e ao número de ocorrências encontradas. No entanto, caso as substrings a serem buscadas se sobreponham, como no caso de um dicionário com "a", "aa", "aaa", "aaaa" e um texto "aaaa", o número de correspondências pode crescer de forma quadrática.</p></div><div class="el-h4"><h4 data-heading="7.4.1.1 Como ele funciona" dir="auto" class="heading" id="7.4.1.1_Como_ele_funciona_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.4.1.1 Como ele funciona</h4></div><div class="el-h5"><h5 data-heading="7.4.1.1.1 Contrução da Trie" dir="auto" class="heading" id="7.4.1.1.1_Contrução_da_Trie_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.4.1.1.1 Contrução da Trie</h5></div><div class="el-p"><p dir="auto">O Aho-Corasick começa construindo um Trie a partir do conjunto de padrões (palavras) que se dejeja buscar no texto. Cada caminho da raiz até um nó terminal da Trie representa uma correspondência de um padrão. Se tivermos os padrões "cat", "car", "bat" e "rat", a Trie seria construída da seguinte maneira:</p></div><div class="el-div"><div align="center">
<img height="400" src="assets/trie-aho-corasick.jpg" referrerpolicy="no-referrer" target="_self">
</div></div><div class="el-h4"><h4 data-heading="7.4.1.2 Links de Falha" dir="auto" class="heading" id="7.4.1.2_Links_de_Falha_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.4.1.2 Links de Falha</h4></div><div class="el-p"><p dir="auto">Depois de construir a Trie, o algoritmo adiciona links de falha aos nós da Trie. Esses links são utilizados para otimizar o processo de busca.</p></div><div class="el-p"><p dir="auto">Links de falha: Quando o algoritmo encontra uma correspondência parcial, mas não completa, ele segue o link de falha para tentar outra possibilidade, sem precisar retroceder. Isso é crucial para garantir que a busca ocorra de maneira eficiente mesmo quando há falhas em algumas correspondências.</p></div><div class="el-p"><p dir="auto">Por exemplo, se estivermos buscando a palavra "rat" no texto e chegarmos ao nó correspondente ao prefixo "ra", mas não houver uma correspondência direta com o próximo caractere "t", o link de falha ajudará o algoritmo a continuar a busca a partir de outro ponto da Trie que ainda seja válido para o caractere "t".</p></div><div class="el-h4"><h4 data-heading="7.4.1.3 Busca no Texto" dir="auto" class="heading" id="7.4.1.3_Busca_no_Texto_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.4.1.3 Busca no Texto</h4></div><div class="el-p"><p dir="auto">Uma vez que a Trie e os links de falha estão construídos, o algoritmo começa a percorrer o texto de entrada.</p></div><div class="el-p"><p dir="auto"><strong>Primeiro passo:</strong> Processamento do Texto<br>
O algoritmo começa lendo o texto caractere por caractere. Para cada caractere, ele o compara com os nós da Trie.</p></div><div class="el-p"><p dir="auto">O que acontece se o caractere do texto corresponder ao nó da Trie? Simplesmente, o algoritmo segue em frente, avançando para o próximo caractere do texto. Ele continua a busca dessa maneira, procurando o padrão em sequência.</p></div><div class="el-p"><p dir="auto">Agora, você pode estar se perguntando:<br>
"E se o caractere no texto não corresponder a nenhum nó na Trie? O que o algoritmo deve fazer?"</p></div><div class="el-p"><p dir="auto"><strong>Segundo passo:</strong> Falha na Correspondência<br>
Quando o caractere do texto não encontra uma correspondência direta na Trie, o algoritmo não retrocede nem começa a busca de novo. Em vez disso, ele usa um mecanismo inteligente chamado link de falha.<br>
Mas como isso funciona?</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>O link de falha é uma espécie de "atalho" que conecta o nó atual da Trie a um nó anterior que pode ter um prefixo comum com o texto atual.</p>
<p>O algoritmo então continua a busca a partir desse novo ponto, tentando corresponder o próximo caractere do texto.</p>
</blockquote></div><div class="el-p"><p dir="auto">Veja o Exemplo:<br>
Imagine que o algoritmo está buscando a palavra "rat" no texto "ratatouille". O algoritmo começa a procurar e encontra o prefixo "ra" no texto.</p></div><div class="el-blockquote"><blockquote dir="auto">
<p>Mas o próximo caractere do texto é "t". O algoritmo encontra a letra "t" na Trie e avança para ela. Agora, se o próximo caractere do texto for "l", que não corresponde ao "t" da Trie, o algoritmo não volta ao início.</p>
<p>Em vez disso, o algoritmo segue o link de falha do nó "ra" até o nó correspondente ao prefixo "r". Ele então continua a busca para o próximo caractere "l", economizando tempo e evitando um retrocesso desnecessário.</p>
</blockquote></div><div class="el-p"><p dir="auto"><strong>Terceiro passo:</strong> Busca Simultânea de Múltiplos Padrões<br>
Uma das principais vantagens do algoritmo Aho-Corasick é que ele não está apenas buscando uma palavra, mas sim vários padrões ao mesmo tempo.</p></div><div class="el-p"><p dir="auto">Mas como isso é possivel?<br>
O algoritmo verifica todos os padrões presentes na Trie simultaneamente enquanto percorre o texto.</p></div><div class="el-p"><p dir="auto">Em vez de verificar um padrão de cada vez, ele pode verificar múltiplos padrões ao mesmo tempo, utilizando a estrutura da Trie para armazenar e organizar esses padrões de forma eficiente.</p></div><div class="el-p"><p dir="auto">Isso torna a busca muito mais rápida, já que ele não precisa repetir a busca para cada palavra. Ele pode verificar todos os padrões ao mesmo tempo, economizando tempo, especialmente quando há um grande número de palavras a serem verificadas em um único texto.</p></div><div class="el-h3"><h3 data-heading="7.4.2 Burst Sort" dir="auto" class="heading" id="7.4.2_Burst_Sort_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.4.2 Burst Sort</h3></div><div class="el-p"><p dir="auto">O Burst Sort é um algoritmo de ordenação eficiente, especialmente para grandes conjuntos de strings ou palavras, onde há muitos prefixos em comum. Criado para lidar com grandes volumes de dados, o Burst Sort divide as strings em "pedaços" e organiza essas partes de maneira otimizada, aproveitando a estrutura de Trie para ordenar eficientemente.</p></div><div class="el-p"><p dir="auto"><strong>Como ele Funciona</strong></p></div><div class="el-h4"><h4 data-heading="7.4.2.1 Divisão das Strings em Pedaços" dir="auto" class="heading" id="7.4.2.1_Divisão_das_Strings_em_Pedaços_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.4.2.1 Divisão das Strings em Pedaços</h4></div><div class="el-p"><p dir="auto">O Burst Sort começa dividindo as strings em "pedaços" menores. Cada "pedaço" é então armazenado em uma estrutura adequada para ordenação eficiente, como uma Trie.</p></div><div class="el-p"><p dir="auto">Porque dividir as Strings?<br>
Ao dividir as strings, o algoritmo consegue otimizar o uso de memória e tornar a ordenação mais rápida, especialmente quando muitas strings compartilham prefixos comuns.</p></div><div class="el-p"><p dir="auto">Após dividir as strings, o Burst Sort armazena cada "pedaço" em uma Trie. A Trie organiza as strings de forma eficiente, aproveitando os prefixos compartilhados para otimizar tanto a memória quanto o tempo de ordenação.</p></div><div class="el-h4"><h4 data-heading="7.4.2.2 Uso de Baldes" dir="auto" class="heading" id="7.4.2.2_Uso_de_Baldes_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.4.2.2 Uso de Baldes</h4></div><div class="el-p"><p dir="auto">Cada nó da Trie pode conter um balde onde são armazenadas as strings que compartilham aquele prefixo. Assim, em vez de espalhar imediatamente todas as strings, elas ficam agrupadas até que o balde atinja um limite de capacidade.</p></div><div class="el-h4"><h4 data-heading="7.4.2.3 Estouro-Burst" dir="auto" class="heading" id="7.4.2.3_Estouro-Burst_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.4.2.3 Estouro-Burst</h4></div><div class="el-p"><p dir="auto">Quando um balde fica cheio, ocorre o Burst (“explosão”):  </p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>O balde é esvaziado.  </li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>As strings nele contidas são distribuídas em novos nós filhos da Trie, seguindo os próximos caracteres.  </li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Isso cria sub-baldes menores, permitindo que a estrutura se ajuste dinamicamente conforme os dados crescem.  </li>
</ul></div><div class="el-hr"><hr></div><div class="el-h4"><h4 data-heading="7.4.2.4 7.4.2.4. Ordenação Local" dir="auto" class="heading" id="7.4.2.4_7.4.2.4._Ordenação_Local_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.4.2.4 7.4.2.4. Ordenação Local</h4></div><div class="el-p"><p dir="auto">Baldes pequenos, que não chegam a estourar, podem ser ordenados localmente usando algoritmos tradicionais como <strong>quicksort</strong> ou <strong>insertion sort</strong>.<br>
Como esses baldes são pequenos, essa ordenação é feita de forma muito rápida.</p></div><div class="el-hr"><hr></div><div class="el-h4"><h4 data-heading="7.4.2.5 7.4.2.5. Geração da Lista Ordenada" dir="auto" class="heading" id="7.4.2.5_7.4.2.5._Geração_da_Lista_Ordenada_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>7.4.2.5 7.4.2.5. Geração da Lista Ordenada</h4></div><div class="el-p"><p dir="auto">No final, para recuperar as strings em <strong>ordem lexicográfica</strong>, basta <strong>percorrer a Trie em ordem</strong>, concatenando os prefixos armazenados.  </p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>A Trie já organiza naturalmente os caracteres em ordem alfabética.  </li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Assim, a saída final é obtida de maneira direta e eficiente.  </li>
</ul></div><div class="el-hr"><hr></div><div class="el-h1"><h1 data-heading="8 Guia para resolução de problemas" dir="auto" class="heading" id="8_Guia_para_resolução_de_problemas_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8 Guia para resolução de problemas</h1></div><div class="el-h2"><h2 data-heading="8.1 Dicas" dir="auto" class="heading" id="8.1_Dicas_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.1 Dicas</h2></div><div class="el-h3"><h3 data-heading="8.1.1 Quando usar uma Trie?" dir="auto" class="heading" id="8.1.1_Quando_usar_uma_Trie?_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.1.1 Quando usar uma Trie?</h3></div><div class="el-p"><p dir="auto"><strong>Passo 1:</strong>  Analisar problema<br>
A primeira pergunta que você deve se fazer é:</p></div><div class="el-blockquote"><blockquote dir="auto">
<p><strong>Que tipos de dados envolve o problema e qual a sua unidade mais básica? "</strong></p>
</blockquote></div><div class="el-p"><p dir="auto">Se a resposta para essa pergunta envolver uma sequência construida através de um alfabeto (conjunto <strong>FINITO</strong> de símbolos), preste bem atenção no finito, essa é uma das premissas chaves, veremos no passo 3 que o tamanho desse conjunto impactará diretamente no consumo de memória. Nesse caso, é um bom sinal de que o problema pode ser resolvido com Trie, pois em sua essência, Trie é uma estrutura otimizada para armazenar e consultar sequências. As sequências mais comuns são as strings, nesse caso, o alfabeto são os caracteres. No entanto, o conceito é bem mais amplo, pode ser uma sequência de digitos, como números de telefones, ou até uma sequência de bits.</p></div><div class="el-p"><p dir="auto"><strong>Passo 2:</strong> Analisar quais as operações chave para resolver o problema.</p></div><div class="el-p"><p dir="auto">Próxima pergunta que você deve fazer, é quais as operações chaves que preciso para resolver o problema, se as operações são baseadas em prefixos, Trie é disparada uma das estruturas de dados que você deve levar em consideração. Ela materializa a ideia de prefixo em sua estrutura, a sua eficiência para suas operações são geralmente <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D442 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math></mjx-container></span>, onde <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi></mjx-math></mjx-container></span> é o comprimento do prefixo. Por exemplo:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>"Liste todas as palavras que começam com ..." (autocompletar)</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>"Verifique se tem alguma palavra com prefixo ..."</li>
</ul></div><div class="el-p"><p dir="auto"><strong>Passo 3:</strong> Botar em consideração as restrições de tempo e espaço do problema</p></div><div class="el-p"><p dir="auto">Tendo Trie como um ótimo candidato, devemos nos perguntar, será ela a estrutura certa? Ela é realmente a melhor opção?</p></div><div class="el-p"><p dir="auto">A Trie é muito boa em remover, inserir, e buscar uma sequência de comprimento <em>L</em>, independente do número total de palavras no dicionário.</p></div><div class="el-p"><p dir="auto">Qual o problema da Trie? Memória!<br>
Para cada nó, pode ter ponteiros para cada elemento no alfabeto, desse modo, se o alfabeto é muito grande, se torna inviavel para implementação de Trie padrão. Então é preciso se perguntar:</p></div><div class="el-blockquote"><blockquote dir="auto">
<p><strong>"O afalbeto é pequeno ou é muito grande?"</strong></p>
</blockquote></div><div class="el-p"><p dir="auto">Bom, e no caso de ser inviável? Considere variações de Trie com otmizações de memória, como uma <em>TST</em>, ou algumas otimizações como guardar um mapa de hash em cada nó invés de uma array fixo, economiza mais memória em troca de um pouco de velocidade.</p></div><div class="el-h2"><h2 data-heading="8.2 Problemas Práticos" dir="auto" class="heading" id="8.2_Problemas_Práticos_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.2 Problemas Práticos</h2></div><div class="el-h3"><h3 data-heading="8.2.1 [Monitoria de LP2](https://www.spoj.com/problems/ADAINDEX/en/)" dir="auto" class="heading" id="8.2.1_[Monitoria_de_LP2](https//www.spoj.com/problems/ADAINDEX/en/)_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.2.1 <a data-tooltip-position="top" aria-label="https://www.spoj.com/problems/ADAINDEX/en/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.spoj.com/problems/ADAINDEX/en/" target="_self">Monitoria de LP2</a></h3></div><div class="el-p"><p dir="auto">Ana, para otimizar seu tempo ao corrigir os inúmeros projetos da disciplina de Laboratório de Programação 2, está desenvolvendo um script de análise de código.</p></div><div class="el-p"><p dir="auto">O primeiro passo de seu script é extrair todos os identificadores (nomes de variáveis, funções, classes, etc.) dos códigos dos alunos e compilá-los em uma grande lista. Agora, para analisar rapidamente os padrões de nomenclatura e a aderência dos alunos às boas práticas, ela precisa de uma forma eficiente de fazer consultas nessa lista.</p></div><div class="el-p"><p dir="auto">O desafio é o seguinte: Você receberá a lista completa de identificadores e algumas consultas em forma de prefixos. Para cada prefixo, sua tarefa é ajudar Ana a descobrir quantos identificadores na lista começam com ele.</p></div><div class="el-p"><p dir="auto"><strong>Entrada</strong><br>
A primeira linha contém N, Q: o número de palavras na lista e o número de consultas.</p></div><div class="el-p"><p dir="auto">Seguem-se N linhas, com palavras consistindo de letras minúsculas. A soma de seus comprimentos não será maior que <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.393em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c36"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-math></mjx-container></span>.</p></div><div class="el-p"><p dir="auto">Seguem-se Q linhas, com palavras (consultas) consistindo de letras minúsculas. A soma de seus comprimentos não será maior que <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.393em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c36"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-math></mjx-container></span>.</p></div><div class="el-p"><p dir="auto"><strong>Saída</strong><br>
Para cada consulta, imprima o número de palavras na lista que começam com a palavra atual.</p></div><div class="el-p"><p dir="auto"><strong>Exemplo</strong></p></div><div class="el-pre"><pre><code data-line="0">12 6
calculartotalpedido
calcularimposto
cliente
clientedadospessoais
clienteservice
listadeclientes
getusuarioporid
usuariorepositorio
usuario
x
a
temp
cliente
calcular
usuario
get
lista
z
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre><code data-line="0">3
2
2
1
1
0
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h3"><h3 data-heading="8.2.2 [Nicks semelhantes](https://codeforces.com/problemset/problem/514/C)" dir="auto" class="heading" id="8.2.2_[Nicks_semelhantes](https//codeforces.com/problemset/problem/514/C)_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.2.2 <a data-tooltip-position="top" aria-label="https://codeforces.com/problemset/problem/514/C" rel="noopener nofollow" class="external-link is-unresolved" href="https://codeforces.com/problemset/problem/514/C" target="_self">Nicks semelhantes</a></h3></div><div class="el-p"><p dir="auto">Gabriel, um ávido jogador de Valorant, está desenvolvendo uma ferramenta para analisar nicks de jogadores. A ideia é encontrar jogadores com nicks parecidos, que possam ser amigos ou contas alternativas (<em>smurfs</em>).</p></div><div class="el-p"><p dir="auto">Inicialmente, a memória de sua ferramenta é preenchida com uma lista de <strong>n</strong> nicks. Em seguida, a ferramenta deve ser capaz de processar consultas do seguinte tipo: "Dado um nick <strong>s</strong>, determine se a memória contém um nick <strong>t</strong> que tenha o mesmo número de caracteres que <strong>s</strong> e que difira de <strong>s</strong> em exatamente uma posição".</p></div><div class="el-p"><p dir="auto">Gabriel já montou a estrutura da ferramenta, só falta escrever o programa para ela e testá-lo com os dados, que consistem em <strong>n</strong> nicks iniciais e <strong>m</strong> consultas. Ele decidiu confiar este trabalho a você.</p></div><div class="el-p"><p dir="auto"><strong>Entrada</strong><br>
A primeira linha contém dois números não negativos <strong>n</strong> e <strong>m</strong> (<span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2264"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="4"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2264"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c33"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c22C5"></mjx-c></mjx-mo><mjx-msup space="3"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.393em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="2"><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2264"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="4"><mjx-c class="mjx-c1D45A TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2264"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c33"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c22C5"></mjx-c></mjx-mo><mjx-msup space="3"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.393em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-math></mjx-container></span>) — o número de nicks iniciais e o número de consultas, respectivamente.</p></div><div class="el-p"><p dir="auto">A seguir, vêm <strong>n</strong> strings não vazias que são carregadas na memória da ferramenta.</p></div><div class="el-p"><p dir="auto">A seguir, vêm <strong>m</strong> strings não vazias que são as consultas para a ferramenta.</p></div><div class="el-p"><p dir="auto">O comprimento total das linhas na entrada não excede <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mn class="mjx-n"><mjx-c class="mjx-c36"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c22C5"></mjx-c></mjx-mo><mjx-msup space="3"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.393em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-math></mjx-container></span>. Cada linha consiste apenas das letras 'a', 'b', 'c'.</p></div><div class="el-p"><p dir="auto"><strong>Saída</strong><br>
Para cada consulta, imprima em uma única linha "<strong>YES</strong>" (sem as aspas), se a memória contiver o nick procurado, caso contrário, imprima "<strong>NO</strong>" (sem as aspas).</p></div><div class="el-p"><p dir="auto"><strong>Exemplo</strong></p></div><div class="el-pre"><pre><code data-line="0">5 6
limaz
bielzzr
yanlira
maddy
addsound
limax
maddy
bielzzy
yanlaro
addsound
limas
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre><code data-line="0">YES
NO
YES
NO
NO
YES
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h3"><h3 data-heading="8.2.3 [Sintonia computacional](https://www.spoj.com/problems/QN01/en/)" dir="auto" class="heading" id="8.2.3_[Sintonia_computacional](https//www.spoj.com/problems/QN01/en/)_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.2.3 <a data-tooltip-position="top" aria-label="https://www.spoj.com/problems/QN01/en/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.spoj.com/problems/QN01/en/" target="_self">Sintonia computacional</a></h3></div><div class="el-p"><p dir="auto">Lucas e Yan, figuras conhecidas nos corredores da UFCG, compartilham uma tradição sagrada: Comer pastel em seu Hélio. Dizem as lendas que a quantidade de ketchup que Lucas coloca no pastel é diretamente proporcional à complexidade do último problema que resolveram.</p></div><div class="el-p"><p dir="auto">Uma coisa que sempre intrigou seus colegas é como eles consistentemente tiram notas muito parecidas em todas as disciplinas. O segredo, segundo eles, está em sua "sintonia computacional". Para provar isso, eles criaram um desafio.</p></div><div class="el-p"><p dir="auto">Dada uma lista de números inteiros, representando as notas que tiraram em várias avaliações, eles querem encontrar o "potencial máximo de colaboração". Esse potencial é definido como o resultado máximo da operação OU-EXCLUSIVO (XOR) entre as notas de duas avaliações (não necessarimanete distintas). Será que você consegue calcular esse valor e desvendar o segredo da dupla?</p></div><div class="el-p"><p dir="auto"><strong>Entrada</strong><br>
A primeira linha é um inteiro <code>n</code>, a quantidade de notas.<br>
A segunda linha é uma lista com todas as notas.</p></div><div class="el-p"><p dir="auto"><strong>Saída</strong><br>
Na primeira linha, um único inteiro, com a maior soma da operação XOR entre as notas de duas avaliações distintas. Na segunda linha a posição <em>i</em> e <em>j</em> das notas utilizadas.</p></div><div class="el-p"><p dir="auto"><strong>Exemplo</strong></p></div><div class="el-pre"><pre><code data-line="0">3
1 2 3
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre><code data-line="0">3
1 2
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h2"><h2 data-heading="8.3 Trie ou não Trie? Eis a questão" dir="auto" class="heading" id="8.3_Trie_ou_não_Trie?_Eis_a_questão_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.3 Trie ou não Trie? Eis a questão</h2></div><div class="el-h3"><h3 data-heading="8.3.1 Problema 1: Lista Telefônica" dir="auto" class="heading" id="8.3.1_Problema_1_Lista_Telefônica_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.3.1 Problema 1: Lista Telefônica</h3></div><div class="el-p"><p dir="auto"><strong>Descrição:</strong> Você recebe uma lista de números de telefone. Sua tarefa é determinar se a lista é consistente, ou seja, se nenhum número é prefixo de outro. Por exemplo, se a lista contém "911" e "911254", ela é inconsistente. </p></div><div class="el-p"><p dir="auto"><strong>Pergunta:</strong> A Trie é uma boa estrutura para resolver este problema? Por quê?</p></div><div class="el-h3"><h3 data-heading="8.3.2 Problema 2: Verificador de Anagramas" dir="auto" class="heading" id="8.3.2_Problema_2_Verificador_de_Anagramas_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.3.2 Problema 2: Verificador de Anagramas</h3></div><div class="el-p"><p dir="auto"><strong>Descrição:</strong> Dadas duas palavras, determine se uma é um anagrama da outra (contém exatamente as mesmas letras, na mesma quantidade, mas em ordem diferente). Por exemplo, "amor" e "roma" são anagramas. </p></div><div class="el-p"><p dir="auto"><strong>Pergunta:</strong> A Trie ajudaria a resolver este problema de forma eficiente? Qual seria a abordagem principal?</p></div><div class="el-h3"><h3 data-heading="8.3.3 Problema 3: Autocompletar para Contatos" dir="auto" class="heading" id="8.3.3_Problema_3_Autocompletar_para_Contatos_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.3.3 Problema 3: Autocompletar para Contatos</h3></div><div class="el-p"><p dir="auto"><strong>Descrição:</strong> Você está implementando a busca em uma lista de contatos. Ao digitar as primeiras letras de um nome, o sistema deve sugerir todos os contatos que começam com essas letras. </p></div><div class="el-p"><p dir="auto"><strong>Pergunta:</strong> Qual estrutura de dados você usaria para implementar essa funcionalidade de forma que as sugestões apareçam quase instantaneamente?</p></div><div class="el-h3"><h3 data-heading="8.3.4 Problema 4: Substring Comum Mais Longa" dir="auto" class="heading" id="8.3.4_Problema_4_Substring_Comum_Mais_Longa_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.3.4 Problema 4: Substring Comum Mais Longa</h3></div><div class="el-p"><p dir="auto"><strong>Descrição:</strong> Dadas duas strings, encontre a substring mais longa que aparece em ambas. Por exemplo, para "banana" e "cabana", a resposta é "bana". </p></div><div class="el-p"><p dir="auto"><strong>Pergunta:</strong> Seria possível usar uma Trie padrão para encontrar a substring comum mais longa? Qual é a dificuldade?</p></div><div class="el-h3"><h3 data-heading="8.3.5 Problema 5: Banco de Senhas" dir="auto" class="heading" id="8.3.5_Problema_5_Banco_de_Senhas_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.3.5 Problema 5: Banco de Senhas</h3></div><div class="el-p"><p dir="auto"><strong>Descrição:</strong> Um sistema precisa verificar se uma nova senha escolhida por um usuário já existe em um banco de dados com milhões de senhas conhecidas para evitar senhas duplicadas. A verificação precisa ser extremamente rápida. </p></div><div class="el-p"><p dir="auto"><strong>Pergunta:</strong> Entre uma Trie e um Hash Set (Conjunto de Hash), qual seria mais apropriado para esta tarefa e por quê?</p></div><div class="el-h2"><h2 data-heading="8.4 Gabarito dos Problemas Práticos" dir="auto" class="heading" id="8.4_Gabarito_dos_Problemas_Práticos_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.4 Gabarito dos Problemas Práticos</h2></div><div class="el-h3"><h3 data-heading="8.4.1 [Monitoria de LP2](https://www.spoj.com/problems/ADAINDEX/en/ &quot;null&quot;)" dir="auto" class="heading" id="8.4.1_[Monitoria_de_LP2](https//www.spoj.com/problems/ADAINDEX/en/_&quot;null&quot;)_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.4.1 <a data-tooltip-position="top" aria-label="https://www.spoj.com/problems/ADAINDEX/en/" rel="noopener nofollow" class="external-link is-unresolved" title="null" href="https://www.spoj.com/problems/ADAINDEX/en/" target="_self">Monitoria de LP2</a></h3></div><div class="el-h4"><h4 data-heading="8.4.1.1 Análise do Problema" dir="auto" class="heading" id="8.4.1.1_Análise_do_Problema_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.4.1.1 Análise do Problema</h4></div><div class="el-p"><p dir="auto">À primeira vista, o problema parece ser só uma contagem simples. Mas qual é a pegadinha? A escala. Com milhões de palavras e consultas, uma abordagem de força bruta, checando palavra por palavra, seria um desastre. Simplesmente não passaria no tempo limite. A questão principal, então, não é <em>o quê</em> fazer, mas <em>como</em> fazer isso de forma inteligente e rápida. O enunciado praticamente grita a resposta ao pedir para contar palavras que "começam com" um prefixo. Esse é o território da Trie. Ela nasceu para isso. Então, como a gente usa essa ferramenta da melhor forma possível?</p></div><div class="el-h4"><h4 data-heading="8.4.1.2 Estratégia de Solução" dir="auto" class="heading" id="8.4.1.2_Estratégia_de_Solução_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.4.1.2 Estratégia de Solução</h4></div><div class="el-p"><p dir="auto">O truque aqui é dar uma turbinada na Trie padrão. Não basta ela só guardar as palavras; ela precisa nos ajudar a contar. A gente quer que a própria estrutura já tenha a resposta pronta. Mas como? O pensamento é o seguinte: Se, ao inserir uma palavra, a gente deixasse um "rastro" nos nós por onde ela passou?</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>Estrutura do Nó Aprimorada:</strong> A chave para a velocidade é modificar o tijolo básico da Trie: o nó. Além dos ponteiros para os filhos, cada nó vai ter um contador, que podemos chamar de <code>prefix_count</code>. É uma ideia simples, mas poderosa. Pense nesse contador como um pedágio numa estrada: toda vez que uma palavra "passa" por um nó ao ser inserida, o contador aumenta. </li>
<li data-line="1" dir="auto"><strong>Construção e Agregação:</strong> Na hora de construir a Trie, a mágica acontece. A gente insere cada uma das <code>N</code> palavras, caractere por caractere. O pulo do gato é que cada nó que a gente visita nesse caminho tem seu <code>prefix_count</code> incrementado. O que isso significa na prática? Que um nó passa a saber não só que ele faz parte de um caminho, mas <em>quantas</em> palavras compartilham aquele exato prefixo. No final, a Trie deixa de ser só um dicionário e vira um mapa que mostra o quão popular é cada começo de palavra.</li>
<li data-line="2" dir="auto"><strong>Consulta Super Rápida:</strong> Com a Trie montada desse jeito, a consulta vira uma piada de tão fácil. Para um prefixo qualquer, a gente só precisa passear pela Trie. Se o caminho existir até o final do prefixo, o número guardado no <code>prefix_count</code> daquele último nó já é a nossa resposta. Sem precisar olhar o resto do banco de dados. E se o caminho quebrar no meio? Mais fácil ainda. Quer dizer que nenhuma palavra começa com aquele prefixo, e a resposta é zero.
<div align="center">
  <img height="1200" src="assets/exemplo_problema_monitoria.png" referrerpolicy="no-referrer" target="_self">
</div>
</li>
</ol></div><div class="el-h4"><h4 data-heading="8.4.1.3 Complexidade" dir="auto" class="heading" id="8.4.1.3_Complexidade_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.4.1.3 Complexidade</h4></div><div class="el-p"><p dir="auto">O mais legal dessa abordagem é o resultado final. A complexidade, <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D442 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D446 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em; margin-left: -0.032em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c200B"></mjx-c></mjx-mo></mjx-texatom><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D446 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em; margin-left: -0.032em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D444 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c200B"></mjx-c></mjx-mo></mjx-texatom><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math></mjx-container></span>, ou seja, a soma de todas as palavras inseridas com a soma de todos os prefixos, é linear. Isso quer dizer que o tempo de execução cresce junto com o tamanho da entrada, e não de forma explosiva. É uma otimização gigantesca, tornando a solução não só viável, mas extremamente eficiente.</p></div><div class="el-h3"><h3 data-heading="8.4.2 [Nicks semelhantes](https://codeforces.com/problemset/problem/514/C &quot;null&quot;)" dir="auto" class="heading" id="8.4.2_[Nicks_semelhantes](https//codeforces.com/problemset/problem/514/C_&quot;null&quot;)_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.4.2 <a data-tooltip-position="top" aria-label="https://codeforces.com/problemset/problem/514/C" rel="noopener nofollow" class="external-link is-unresolved" title="null" href="https://codeforces.com/problemset/problem/514/C" target="_self">Nicks semelhantes</a></h3></div><div class="el-h4"><h4 data-heading="8.4.2.1 Análise do Problema" dir="auto" class="heading" id="8.4.2.1_Análise_do_Problema_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.4.2.1 Análise do Problema</h4></div><div class="el-p"><p dir="auto">Este problema já é um pouco mais sutil. A busca não é por uma correspondência exata, nem por um prefixo. O desafio é encontrar uma "semelhança" com uma regra bem específica: mesmo tamanho e diferença em apenas uma posição. Força bruta? Sem chance, seria lento demais. A pista crucial aqui é o alfabeto minúsculo ('a', 'b', 'c'). Um alfabeto tão pequeno limita drasticamente o espaço de busca para variações. Isso é um convite para usar uma estrutura que se organiza por caracteres, como a Trie. A grande questão é: Como podemos vasculhar a Trie em busca de uma correspondência que permite exatamente uma falha?</p></div><div class="el-h4"><h4 data-heading="8.4.2.2 Estratégia de Solução" dir="auto" class="heading" id="8.4.2.2_Estratégia_de_Solução_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.4.2.2 Estratégia de Solução</h4></div><div class="el-p"><p dir="auto">A estratégia se baseia numa ideia bem legal: Uma busca em profundidade (DFS) que funciona como uma "busca com orçamento para erros". A Trie nos dá a estrutura para não repetir trabalho, e a recursão vai controlar esse nosso orçamento.</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>Construção da Trie:</strong> Primeiro, o básico. Inserimos todos os <code>N</code> nicks na Trie, marcando os nós terminais com uma flag <code>isEndOfWord</code> para sabermos onde uma palavra de fato termina.</li>
<li data-line="1" dir="auto"><strong>Consulta Recursiva com Orçamento de Erros:</strong> Para cada consulta <code>s</code>, a gente dispara uma função recursiva que navega pela Trie. O brilhantismo está nos parâmetros que ela carrega: O nó atual, a posição <code>index</code> na string <code>s</code>, e um contador <code>mismatches</code>. Esse contador é o nosso orçamento.<br>
- <strong>Como a busca funciona?</strong> Em cada nó, a gente olha para os possíveis caminhos ('a', 'b', 'c'). Se o caractere do caminho bate com o da nossa string <code>s</code>, ótimo, seguimos em frente sem gastar o orçamento. Mas e se for diferente? Aí a gente gasta uma unidade do orçamento (<code>mismatches</code> aumenta) e continua mesmo assim. É a nossa chance de encontrar a palavra "semelhante".<br>
- <strong>Quando a gente para?</strong> A busca por um caminho é abortada na hora se o orçamento estourar (<code>mismatches &gt; 1</code>). Isso poda a árvore de busca e economiza um tempo absurdo. Por outro lado, se chegarmos ao final da string, uma solução válida só é encontrada se duas condições forem perfeitas: O orçamento foi gasto em exatamente uma unidade (<code>mismatches == 1</code>) e o nó atual representa o fim de uma palavra de verdade (<code>node.isEndOfWord == true</code>).<br>
Essa abordagem sistemática explora todas as variações de uma letra de forma inerentemente eficiente, pois os prefixos comuns a múltiplos nicks são percorridos apenas uma vez.</li>
</ol></div><div class="el-h4"><h4 data-heading="8.4.2.3 Complexidade" dir="auto" class="heading" id="8.4.2.3_Complexidade_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.4.2.3 Complexidade</h4></div><div class="el-p"><p dir="auto">A construção é linear em relação à soma dos comprimentos dos nicks, <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D442 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mo class="mjx-sop"><mjx-c class="mjx-c2211 TEX-S1"></mjx-c></mjx-mo><mjx-texatom space="2" texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D450 TEX-I"></mjx-c></mjx-mi><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D458 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math></mjx-container></span>. A consulta para uma string de comprimento <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi></mjx-math></mjx-container></span> tem uma complexidade de aproximadamente <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D442 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43F TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c22C5"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2223"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="4"><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c6C"></mjx-c><mjx-c class="mjx-c66"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c62"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c6F"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2223"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math></mjx-container></span>, pois em cada nível, no pior caso, exploramos um pequeno número de ramos. O tempo total é, portanto, ordens de magnitude mais rápido que a abordagem ingênua, sendo independente do número total de nicks na base de dados durante a fase de consulta. </p></div><div class="el-h3"><h3 data-heading="8.4.3 [Sintonia computacional](https://www.spoj.com/problems/QN01/en/)" dir="auto" class="heading" id="8.4.3_[Sintonia_computacional](https//www.spoj.com/problems/QN01/en/)_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.4.3 <a data-tooltip-position="top" aria-label="https://www.spoj.com/problems/QN01/en/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.spoj.com/problems/QN01/en/" target="_self">Sintonia computacional</a></h3></div><div class="el-h4"><h4 data-heading="8.4.3.1 Análise do Problema" dir="auto" class="heading" id="8.4.3.1_Análise_do_Problema_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.4.3.1 Análise do Problema</h4></div><div class="el-p"><p dir="auto">Aqui a Trie vai além do mundo das palavras e mergulha nas operações de bits. O desafio de achar o maior XOR possível entre dois números de uma lista enorme mostra na hora que a força bruta (<span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D442 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msup><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em; margin-left: 0.054em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math></mjx-container></span>) não é uma opção. A solução exige uma virada de chave no nosso pensamento. E se a gente parasse de ver os números como<span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mo class="mjx-n"><mjx-c class="mjx-c2026"></mjx-c></mjx-mo></mjx-math></mjx-container></span> bem, números, e passasse a vê-los como sequências de bits? Essa abstração é a porta de entrada para a <strong>Trie Binária</strong>. A gente vai organizar os números pelos seus prefixos binários, e essa é a chave para uma busca muito mais rápida.</p></div><div class="el-h4"><h4 data-heading="8.4.3.2 Estratégia de Solução" dir="auto" class="heading" id="8.4.3.2_Estratégia_de_Solução_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.4.3.2 Estratégia de Solução</h4></div><div class="el-p"><p dir="auto">A solução se apoia numa estratégia gulosa (ou "esganada"), que a Trie Binária torna possível. Pense bem, qual é o segredo para maximizar um número em binário? É fazer seus bits mais à esquerda, os que valem mais, serem iguais a <code>1</code>.</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>Estrutura e Construção:</strong> A gente monta uma Trie onde cada nó tem no máximo dois filhos: <code>0</code> e <code>1</code>. Simples assim. Cada número da lista é inserido como um caminho de <code>K</code> bits (por exemplo, cerca de 31 para um <code>int</code>), do mais importante (MSB) para o menos importante (LSB).</li>
<li data-line="1" dir="auto"><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><strong>Busca Gulosa:</strong> Para cada número <code>x</code> da lista, a gente vai caçar na Trie o seu par perfeito <code>y</code>. Como essa caçada funciona? Para cada bit de <code>x</code>, do mais valioso para o menos, a gente aplica uma lógica gulosa.
<ul class="has-list-bullet">
<li data-line="2" dir="auto"><span class="list-bullet"></span>A gente sabe que <code>a XOR b</code> dá <code>1</code> se <code>a</code> e <code>b</code> forem diferentes. Certo? Então, para fazer o resultado ser o maior possível, se o bit atual de <code>x</code> é <code>0</code>, a gente quer muito achar um caminho na Trie que comece com <code>1</code>. Por isso, tentamos descer pelo filho <code>1</code>. Se o bit de <code>x</code> é <code>1</code>, a gente faz o contrário, buscando o caminho <code>0</code>.</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span>É como se estivéssemos construindo o par ideal para o XOR, bit a bit. Em cada nível da Trie, a gente faz a escolha que "liga" o bit mais valioso que der no resultado. E se o caminho ideal (o bit oposto) não existir? Aí não tem jeito, somos forçados a seguir pelo que tem, e aceitamos um <code>0</code> naquela posição do resultado.</li>
<li data-line="4" dir="auto"><span class="list-bullet"></span>Ao final dessa viagem de <code>K</code> passos, teremos encontrado o número que dá o maior XOR possível com <code>x</code>.</li>
</ul>
</li>
</ol></div><div class="el-p"><p dir="auto">A gente guarda o maior valor de XOR que encontrarmos no geral e as indexações para dar a resposta final.</p></div><div class="el-div"><div align="center">
  <img height="300" src="assets/exemplo_problema_sintonia.png" referrerpolicy="no-referrer" target="_self">
</div></div><div class="el-h4"><h4 data-heading="8.4.3.3 Complexidade" dir="auto" class="heading" id="8.4.3.3_Complexidade_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.4.3.3 Complexidade</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><strong>Seja K o número de bits na representação dos números (ex: 31).</strong></li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><strong>Tempo de Construção:</strong> <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D442 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c22C5"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D43E TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math></mjx-container></span>.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><strong>Tempo de Busca:</strong> Para cada um dos <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi></mjx-math></mjx-container></span> números, fazemos uma busca de profundidade <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D43E TEX-I"></mjx-c></mjx-mi></mjx-math></mjx-container></span>. Logo, <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D442 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c22C5"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D43E TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math></mjx-container></span>.</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span><strong>Tempo Total:</strong> <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D442 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c22C5"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D43E TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math></mjx-container></span>, uma melhoria drástica em relação ao <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D442 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msup><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D441 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: 0.363em; margin-left: 0.054em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math></mjx-container></span> da força bruta.</li>
</ul></div><div class="el-h2"><h2 data-heading="8.5 Gabarito dos Desafios" dir="auto" class="heading" id="8.5_Gabarito_dos_Desafios_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.5 Gabarito dos Desafios</h2></div><div class="el-h3"><h3 data-heading="8.5.1 Problema 1: Lista Telefônica" dir="auto" class="heading" id="8.5.1_Problema_1_Lista_Telefônica_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.5.1 Problema 1: Lista Telefônica</h3></div><div class="el-p"><p dir="auto"><strong>Veredito:</strong> Pode apostar todas as fichas: a Trie é a resposta.</p></div><div class="el-h4"><h4 data-heading="8.5.1.1 Análise Passo a Passo" dir="auto" class="heading" id="8.5.1.1_Análise_Passo_a_Passo_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.5.1.1 Análise Passo a Passo</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><strong>Passo 1 (Analisar Problema):</strong> Pense bem, o que são números de telefone? Em sua essência, são apenas <strong>-&gt; sequências de dígitos &lt;-</strong>. Nosso universo se resume ao alfabeto de <code>0</code> a <code>9</code>, um conjunto bem específico e limitado. Esse cenário, por si só, já deveria acender um letreiro em neon na sua cabeça: "Hmm, isso tem cheiro de Trie".</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><strong>Passo 2 (Analisar Operações):</strong> A alma deste desafio pulsa em uma única palavra: <strong>"prefixo"</strong>. Precisamos saber se um número é o ponto de partida de outro. E qual estrutura de dados parece ter sido desenhada com a palavra "prefixo" em mente? Exato, a Trie. Ela não é apenas uma candidata; é a principal suspeita desde o início.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><strong>Passo 3 (Analisar Restrições):</strong> A Trie, neste caso, opera como um detetive particularmente astuto. Ela confere a consistência no exato momento da inserção, sem nenhum trabalho extra. Visualize o "911254" sendo adicionado depois do "911". A Trie, ao percorrer o caminho <code>9 -&gt; 1 -&gt; 1</code>, nota na hora: "Ei, este nó por onde estou passando já marca o fim de outra palavra!". Fim de jogo: a lista é inconsistente. O inverso também funciona: se inserirmos "911" e o nó do último <code>1</code> já tem uma continuação (o <code>2</code>), a Trie deduz: "Entendi, o número que acabei de registrar é o começo de outro já existente!". É simples, é elegante e de uma eficiência brutal.</li>
</ul></div><div class="el-h3"><h3 data-heading="8.5.2 Problema 2: Verificador de Anagramas" dir="auto" class="heading" id="8.5.2_Problema_2_Verificador_de_Anagramas_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.5.2 Problema 2: Verificador de Anagramas</h3></div><div class="el-p"><p dir="auto"><strong>Veredito:</strong> De jeito nenhum. Tentar usar uma Trie aqui é uma cilada.</p></div><div class="el-h4"><h4 data-heading="8.5.2.1 Análise Passo a Passo" dir="auto" class="heading" id="8.5.2.1_Análise_Passo_a_Passo_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.5.2.1 Análise Passo a Passo</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><strong>Passo 1 (Analisar Problema):</strong> A primeira impressão até que engana. Estamos lidando com strings, que são sequências dentro de um alfabeto finito. Parece o território perfeito, certo? A história é outra.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><strong>Passo 2 (Analisar Operações):</strong> É neste ponto que o castelo de cartas da Trie desmorona. A tarefa é verificar anagramas. E qual é a regra de ouro, o DNA de um anagrama? A <strong>ordem dos caracteres não significa nada</strong>; o que importa é a contagem de cada um. Agora, qual é o pilar que sustenta uma Trie? A <strong>-&gt; ordem é sagrada &lt;-</strong>. Seus caminhos são construídos a partir da sequência exata dos caracteres. Querer resolver anagramas com uma Trie é como tentar montar um quebra-cabeça usando um mapa rodoviário. A ferramenta simplesmente não conversa com a lógica do problema.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><strong>Passo 3 (Analisar Restrições):</strong> Forçar o uso de uma Trie aqui seria um monumental desperdício de tempo e de linhas de código. A solução de verdade é ridiculamente mais simples. Que tal apenas contar a frequência de cada letra nas duas palavras? Se os totais baterem, são anagramas. Ou, mais direto ainda: coloque as letras de cada palavra em ordem alfabética. Se os resultados forem idênticos, temos um vencedor. Ambas as abordagens são muito mais rápidas e infinitamente mais lógicas.</li>
</ul></div><div class="el-h3"><h3 data-heading="8.5.3 Problema 3: Autocompletar para Contatos" dir="auto" class="heading" id="8.5.3_Problema_3_Autocompletar_para_Contatos_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.5.3 Problema 3: Autocompletar para Contatos</h3></div><div class="el-p"><p dir="auto"><strong>Veredito:</strong> Este é o palco perfeito para a Trie brilhar.</p></div><div class="el-h4"><h4 data-heading="8.5.3.1 Análise Passo a Passo" dir="auto" class="heading" id="8.5.3.1_Análise_Passo_a_Passo_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.5.3.1 Análise Passo a Passo</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><strong>Passo 1 (Analisar Problema):</strong> Temos nomes de contatos. São, por natureza, sequências de caracteres de um alfabeto definido. Nenhum mistério por aqui.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><strong>Passo 2 (Analisar Operações):</strong> O que o enunciado pede, exatamente? "Sugerir todos os contatos que <strong>começam com</strong>...". Isso não é só uma pista; é a descrição funcional do superpoder de uma Trie. Já parou pra pensar como a busca do seu smartphone cospe sugestões de nomes antes mesmo de você piscar? Não tem feitiçaria, só a estrutura de dados correta fazendo seu trabalho.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><strong>Passo 3 (Analisar Restrições):</strong> A Trie é a escolha canônica para esta tarefa, ponto final. Buscar pelo prefixo <code>jo</code> é uma operação quase instantânea. Ao alcançarmos o nó que representa o final de <code>jo</code>, a Trie se comporta como um sistema de arquivos incrivelmente otimizado: a partir dali, basta listar todos os "arquivos" (os nomes completos) contidos naquela "pasta". Uma busca em profundidade (DFS) partindo daquele ponto resolve a questão de maneira limpa, rápida e eficiente. Para um sistema que exige respostas em frações de segundo, não existe competidor à altura.</li>
</ul></div><div class="el-h3"><h3 data-heading="8.5.4 Problema 4: Substring Comum Mais Longa" dir="auto" class="heading" id="8.5.4_Problema_4_Substring_Comum_Mais_Longa_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.5.4 Problema 4: Substring Comum Mais Longa</h3></div><div class="el-p"><p dir="auto"><strong>Veredito:</strong> Uma Trie comum não dá conta do recado. Precisamos de mais poder de fogo.</p></div><div class="el-h4"><h4 data-heading="8.5.4.1 Análise Passo a Passo" dir="auto" class="heading" id="8.5.4.1_Análise_Passo_a_Passo_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.5.4.1 Análise Passo a Passo</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><strong>Passo 1 (Analisar Problema):</strong> De volta às strings. O ponto de partida parece familiar e seguro.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><strong>Passo 2 (Analisar Operações):</strong> Agora vem a virada na trama. A palavra que muda completamente o jogo é <strong>"substring"</strong>. Uma Trie lida maravilhosamente bem com prefixos, que são a porta da frente de uma palavra; ela só se importa com o começo. Uma substring, por outro lado, é um pedaço que pode ser extraído de qualquer lugar, do meio, do fim. A Trie padrão, com seu foco no ponto de partida, é míope para o que acontece no interior da palavra.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><strong>Passo 3 (Analisar Restrições):</strong> Usar uma Trie padrão aqui nos entregaria, no máximo, o prefixo comum mais longo, o que não resolve o problema. E se a gente turbinasse a Trie? Pense na palavra "banana" e imagine inserir na Trie não só ela, mas todos os seus sufixos: "anana", "nana", "ana", "na" e "a". Se replicarmos esse processo para todas as palavras, a resposta que buscamos emerge. Essa estrutura "anabolizada" tem nome e sobrenome: <strong>Árvore de Sufixos (Suffix Tree)</strong>, a prima mais velha e mais forte da Trie, projetada sob medida para este tipo de desafio.</li>
</ul></div><div class="el-h3"><h3 data-heading="8.5.5 Problema 5: Banco de Senhas" dir="auto" class="heading" id="8.5.5_Problema_5_Banco_de_Senhas_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.5.5 Problema 5: Banco de Senhas</h3></div><div class="el-p"><p dir="auto"><strong>Veredito:</strong> Embora funcione, um Hash Set é a ferramenta certa para o trabalho.</p></div><div class="el-h4"><h4 data-heading="8.5.5.1 Análise Passo a Passo" dir="auto" class="heading" id="8.5.5.1_Análise_Passo_a_Passo_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>8.5.5.1 Análise Passo a Passo</h4></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><strong>Passo 1 (Analisar Problema):</strong> Senhas são strings. Sequências de caracteres de um alfabeto. Na teoria, o terreno é fértil para uma Trie.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><strong>Passo 2 (Analisar Operações):</strong> Qual é a missão aqui? Uma busca por <strong>existência exata</strong>. A pergunta é direta: "esta senha está no banco de dados?". Queremos um "sim" ou um "não", nada mais. Não há necessidade de prefixos, de sugestões, de nada além de uma consulta de pertencimento.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><strong>Passo 3 (Analisar Restrições):</strong> É aqui que a gente precisa pensar como um bom artesão: usar a ferramenta ideal para cada tarefa. Uma Trie é um canivete suíço, cheia de funções úteis. Um <strong>Hash Set</strong>, por outro lado, é uma chave de fenda: faz uma única coisa, mas com uma velocidade e precisão absurdas. Para a simples tarefa de checar se a senha existe, não precisamos do arsenal do canivete; a chave de fenda resolve. Um Hash Set entrega a resposta em tempo médio constante, O(1). É mais simples de implementar para este fim e, muitas vezes, mais eficiente em termos de memória. A Trie até daria conta, mas seria um exagero desnecessário.</li>
</ul></div><div class="footer"><div class="data-bar"></div></div></div></div></div><div id="right-content" class="leaf" style="--sidebar-width: var(--sidebar-width-right);"><div id="right-sidebar" class="sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme-toggle-input" id=""><input class="theme-toggle-input" type="checkbox" id="theme-toggle-input"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content-wrapper"><div id="right-sidebar-content" class="leaf-content"><div class="graph-view-wrapper"><div class="feature-header"><div class="feature-title">Interactive Graph</div></div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<div class="graph-icon graph-global" role="button" aria-label="Global Graph" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-git-fork"><circle cx="12" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><circle cx="18" cy="6" r="3"></circle><path d="M18 9v2c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V9"></path><path d="M12 12v3"></path></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div id="outline" class=" tree-container"><div class="feature-header"><div class="feature-title">Table Of Contents</div><button class="clickable-icon nav-action-button tree-collapse-all" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="readme.html#README_0" data-path="#README_0"><div class="tree-item-inner heading-link" heading-name="README">README</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="readme.html#1_Motivação_0" data-path="#1_Motivação_0"><div class="tree-item-inner heading-link" heading-name="1 Motivação">1 Motivação</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="readme.html#2_Visão_Geral_em_Vídeo_Trie_em_3_Minutos_0" data-path="#2_Visão_Geral_em_Vídeo_Trie_em_3_Minutos_0"><div class="tree-item-inner heading-link" heading-name="2 Visão Geral em Vídeo: Trie em 3 Minutos">2 Visão Geral em Vídeo: Trie em 3 Minutos</div></a><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible" data-depth="1"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#3_Introdução_0" data-path="#3_Introdução_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="3 Introdução">3 Introdução</div></a><div class="tree-item-children"><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="readme.html#3.1_O_que_é_uma_Trie?_0" data-path="#3.1_O_que_é_uma_Trie?_0"><div class="tree-item-inner heading-link" heading-name="3.1 O que é uma Trie?">3.1 O que é uma Trie?</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="readme.html#3.2_Visualizando_0" data-path="#3.2_Visualizando_0"><div class="tree-item-inner heading-link" heading-name="3.2 Visualizando">3.2 Visualizando</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="1"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#4_Implementação_0" data-path="#4_Implementação_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="4 Implementação">4 Implementação</div></a><div class="tree-item-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#4.1_Estruturas_fundamentais_0" data-path="#4.1_Estruturas_fundamentais_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="4.1 Estruturas fundamentais">4.1 Estruturas fundamentais</div></a><div class="tree-item-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#4.1.1_Node_0" data-path="#4.1.1_Node_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="4.1.1 Node">4.1.1 Node</div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#4.1.1.1_Atributos_0" data-path="#4.1.1.1_Atributos_0"><div class="tree-item-inner heading-link" heading-name="4.1.1.1 Atributos">4.1.1.1 Atributos</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#4.1.2_Trie_0" data-path="#4.1.2_Trie_0"><div class="tree-item-inner heading-link" heading-name="4.1.2 Trie">4.1.2 Trie</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#4.2_Operações_0" data-path="#4.2_Operações_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="4.2 Operações">4.2 Operações</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#4.2.1_Inserção_0" data-path="#4.2.1_Inserção_0"><div class="tree-item-inner heading-link" heading-name="4.2.1 Inserção">4.2.1 Inserção</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#4.2.2_Pesquisa_0" data-path="#4.2.2_Pesquisa_0"><div class="tree-item-inner heading-link" heading-name="4.2.2 Pesquisa">4.2.2 Pesquisa</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#4.2.3_Prefixos_0" data-path="#4.2.3_Prefixos_0"><div class="tree-item-inner heading-link" heading-name="4.2.3 Prefixos">4.2.3 Prefixos</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#4.2.4_Remoção_0" data-path="#4.2.4_Remoção_0"><div class="tree-item-inner heading-link" heading-name="4.2.4 Remoção">4.2.4 Remoção</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="readme.html#4.3_Listagem_de_palavras_por_prefixos_0" data-path="#4.3_Listagem_de_palavras_por_prefixos_0"><div class="tree-item-inner heading-link" heading-name="4.3 Listagem de palavras por prefixos">4.3 Listagem de palavras por prefixos</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="readme.html#4.4_Análise_de_complexidade_de_tempo_e_memória_0" data-path="#4.4_Análise_de_complexidade_de_tempo_e_memória_0"><div class="tree-item-inner heading-link" heading-name="4.4 Análise de complexidade de tempo e memória">4.4 Análise de complexidade de tempo e memória</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="1"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#5_Comparações_0" data-path="#5_Comparações_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="5 Comparações">5 Comparações</div></a><div class="tree-item-children"><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="readme.html#5.1_Trie_x_Hashtable_0" data-path="#5.1_Trie_x_Hashtable_0"><div class="tree-item-inner heading-link" heading-name="5.1 Trie x Hashtable">5.1 Trie x Hashtable</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="readme.html#5.2_Comparação_Trie_vs_Árvore_Balanceada_0" data-path="#5.2_Comparação_Trie_vs_Árvore_Balanceada_0"><div class="tree-item-inner heading-link" heading-name="5.2 Comparação: Trie vs Árvore Balanceada">5.2 Comparação: Trie vs Árvore Balanceada</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="1"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#6_Variações_e_otimizações_0" data-path="#6_Variações_e_otimizações_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="6 Variações e otimizações">6 Variações e otimizações</div></a><div class="tree-item-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#6.1_Radix_Tree_0" data-path="#6.1_Radix_Tree_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="6.1 Radix Tree">6.1 Radix Tree</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.1.1_Definição_0" data-path="#6.1.1_Definição_0"><div class="tree-item-inner heading-link" heading-name="6.1.1 Definição">6.1.1 Definição</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.1.2_Motivação_0" data-path="#6.1.2_Motivação_0"><div class="tree-item-inner heading-link" heading-name="6.1.2 Motivação">6.1.2 Motivação</div></a><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#6.1.3_Operações_0" data-path="#6.1.3_Operações_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="6.1.3 Operações">6.1.3 Operações</div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.1.3.1_Inserção_0" data-path="#6.1.3.1_Inserção_0"><div class="tree-item-inner heading-link" heading-name="6.1.3.1 Inserção">6.1.3.1 Inserção</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.1.3.2_Busca_0" data-path="#6.1.3.2_Busca_0"><div class="tree-item-inner heading-link" heading-name="6.1.3.2 Busca">6.1.3.2 Busca</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.1.3.3_Remoção_0" data-path="#6.1.3.3_Remoção_0"><div class="tree-item-inner heading-link" heading-name="6.1.3.3 Remoção">6.1.3.3 Remoção</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.1.4_Complexidade_0" data-path="#6.1.4_Complexidade_0"><div class="tree-item-inner heading-link" heading-name="6.1.4 Complexidade">6.1.4 Complexidade</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#6.2_Succinct_Trie_0" data-path="#6.2_Succinct_Trie_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="6.2 Succinct Trie">6.2 Succinct Trie</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.2.1_Definição_0" data-path="#6.2.1_Definição_0"><div class="tree-item-inner heading-link" heading-name="6.2.1 Definição">6.2.1 Definição</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.2.2_Motivação_0" data-path="#6.2.2_Motivação_0"><div class="tree-item-inner heading-link" heading-name="6.2.2 Motivação">6.2.2 Motivação</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.2.3_Complexidade_0" data-path="#6.2.3_Complexidade_0"><div class="tree-item-inner heading-link" heading-name="6.2.3 Complexidade">6.2.3 Complexidade</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#6.3_Concurrent_Tries_0" data-path="#6.3_Concurrent_Tries_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="6.3 Concurrent Tries">6.3 Concurrent Tries</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.3.1_Definição_0" data-path="#6.3.1_Definição_0"><div class="tree-item-inner heading-link" heading-name="6.3.1 Definição">6.3.1 Definição</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.3.2_Motivação_0" data-path="#6.3.2_Motivação_0"><div class="tree-item-inner heading-link" heading-name="6.3.2 Motivação">6.3.2 Motivação</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.3.3_Lock-Based_Tries_0" data-path="#6.3.3_Lock-Based_Tries_0"><div class="tree-item-inner heading-link" heading-name="6.3.3 Lock-Based Tries">6.3.3 Lock-Based Tries</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.3.4_Lock-Free_Tries_0" data-path="#6.3.4_Lock-Free_Tries_0"><div class="tree-item-inner heading-link" heading-name="6.3.4 Lock-Free Tries">6.3.4 Lock-Free Tries</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.3.5_Immutable_Tries_0" data-path="#6.3.5_Immutable_Tries_0"><div class="tree-item-inner heading-link" heading-name="6.3.5 Immutable Tries">6.3.5 Immutable Tries</div></a><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#6.3.6_Operações_0" data-path="#6.3.6_Operações_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="6.3.6 Operações">6.3.6 Operações</div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.3.6.1_Inserção_0" data-path="#6.3.6.1_Inserção_0"><div class="tree-item-inner heading-link" heading-name="6.3.6.1 Inserção">6.3.6.1 Inserção</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.3.6.2_Busca_0" data-path="#6.3.6.2_Busca_0"><div class="tree-item-inner heading-link" heading-name="6.3.6.2 Busca">6.3.6.2 Busca</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.3.6.3_Remoção_0" data-path="#6.3.6.3_Remoção_0"><div class="tree-item-inner heading-link" heading-name="6.3.6.3 Remoção">6.3.6.3 Remoção</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.3.6.4_Snapshot_0" data-path="#6.3.6.4_Snapshot_0"><div class="tree-item-inner heading-link" heading-name="6.3.6.4 Snapshot">6.3.6.4 Snapshot</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.3.7_Complexidade_0" data-path="#6.3.7_Complexidade_0"><div class="tree-item-inner heading-link" heading-name="6.3.7 Complexidade">6.3.7 Complexidade</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#6.4_BURST_TRIES_0" data-path="#6.4_BURST_TRIES_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="6.4 BURST TRIES">6.4 BURST TRIES</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.4.1_Definição_0" data-path="#6.4.1_Definição_0"><div class="tree-item-inner heading-link" heading-name="6.4.1 Definição">6.4.1 Definição</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.4.2_Motivação_0" data-path="#6.4.2_Motivação_0"><div class="tree-item-inner heading-link" heading-name="6.4.2 Motivação">6.4.2 Motivação</div></a><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#6.4.3_Operações_0" data-path="#6.4.3_Operações_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="6.4.3 Operações">6.4.3 Operações</div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.4.3.1_Inserção_0" data-path="#6.4.3.1_Inserção_0"><div class="tree-item-inner heading-link" heading-name="6.4.3.1 Inserção">6.4.3.1 Inserção</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.4.3.2_Busca_0" data-path="#6.4.3.2_Busca_0"><div class="tree-item-inner heading-link" heading-name="6.4.3.2 Busca">6.4.3.2 Busca</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.4.3.3_Remoção_0" data-path="#6.4.3.3_Remoção_0"><div class="tree-item-inner heading-link" heading-name="6.4.3.3 Remoção">6.4.3.3 Remoção</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.4.4_Complexidade_0" data-path="#6.4.4_Complexidade_0"><div class="tree-item-inner heading-link" heading-name="6.4.4 Complexidade">6.4.4 Complexidade</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#6.5_Ternary_Search_Tries_0" data-path="#6.5_Ternary_Search_Tries_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="6.5 Ternary Search Tries">6.5 Ternary Search Tries</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.5.1_Definição_0" data-path="#6.5.1_Definição_0"><div class="tree-item-inner heading-link" heading-name="6.5.1 Definição">6.5.1 Definição</div></a><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#6.5.2_Operações_0" data-path="#6.5.2_Operações_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="6.5.2 Operações">6.5.2 Operações</div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.5.2.1_Inserção_0" data-path="#6.5.2.1_Inserção_0"><div class="tree-item-inner heading-link" heading-name="6.5.2.1 Inserção">6.5.2.1 Inserção</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.5.2.2_Busca_0" data-path="#6.5.2.2_Busca_0"><div class="tree-item-inner heading-link" heading-name="6.5.2.2 Busca">6.5.2.2 Busca</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.5.2.3_Remoção_0" data-path="#6.5.2.3_Remoção_0"><div class="tree-item-inner heading-link" heading-name="6.5.2.3 Remoção">6.5.2.3 Remoção</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#6.5.2.4_Busca_por_prefixo_0" data-path="#6.5.2.4_Busca_por_prefixo_0"><div class="tree-item-inner heading-link" heading-name="6.5.2.4 Busca por prefixo">6.5.2.4 Busca por prefixo</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#6.5.3_Complexidade_0" data-path="#6.5.3_Complexidade_0"><div class="tree-item-inner heading-link" heading-name="6.5.3 Complexidade">6.5.3 Complexidade</div></a><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="1"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#7_Aplicações_no_mundo_real_0" data-path="#7_Aplicações_no_mundo_real_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="7 Aplicações no mundo real">7 Aplicações no mundo real</div></a><div class="tree-item-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#7.1_Rede_de_Computadores_0" data-path="#7.1_Rede_de_Computadores_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="7.1 Rede de Computadores">7.1 Rede de Computadores</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#7.1.1_Roteamento_de_Pacotes_IP_0" data-path="#7.1.1_Roteamento_de_Pacotes_IP_0"><div class="tree-item-inner heading-link" heading-name="7.1.1 Roteamento de Pacotes IP">7.1.1 Roteamento de Pacotes IP</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#7.2_Análise_de_Sequências_de_DNA_0" data-path="#7.2_Análise_de_Sequências_de_DNA_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="7.2 Análise de Sequências de DNA">7.2 Análise de Sequências de DNA</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#7.2.1_Armazenamento_e_Busca_em_Grandes_Volumes_de_Dados_Genéticos_0" data-path="#7.2.1_Armazenamento_e_Busca_em_Grandes_Volumes_de_Dados_Genéticos_0"><div class="tree-item-inner heading-link" heading-name="7.2.1 Armazenamento e Busca em Grandes Volumes de Dados Genéticos">7.2.1 Armazenamento e Busca em Grandes Volumes de Dados Genéticos</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#7.3_PLN_-_Processamento_de_Linguagem_Natural_0" data-path="#7.3_PLN_-_Processamento_de_Linguagem_Natural_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="7.3 PLN - Processamento de Linguagem Natural">7.3 PLN - Processamento de Linguagem Natural</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#7.3.1_Manipulação_e_Análise_de_Texto_em_Grande_Escala_0" data-path="#7.3.1_Manipulação_e_Análise_de_Texto_em_Grande_Escala_0"><div class="tree-item-inner heading-link" heading-name="7.3.1 Manipulação e Análise de Texto em Grande Escala">7.3.1 Manipulação e Análise de Texto em Grande Escala</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#7.4_Algoritmos_de_Busca_e_Ordenação_0" data-path="#7.4_Algoritmos_de_Busca_e_Ordenação_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="7.4 Algoritmos de Busca e Ordenação">7.4 Algoritmos de Busca e Ordenação</div></a><div class="tree-item-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#7.4.1_Algoritmo_de_Aho-Corasick_0" data-path="#7.4.1_Algoritmo_de_Aho-Corasick_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="7.4.1 Algoritmo de Aho-Corasick">7.4.1 Algoritmo de Aho-Corasick</div></a><div class="tree-item-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#7.4.1.1_Como_ele_funciona_0" data-path="#7.4.1.1_Como_ele_funciona_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="7.4.1.1 Como ele funciona">7.4.1.1 Como ele funciona</div></a><div class="tree-item-children"><div class="tree-item" data-depth="5"><a class="tree-item-self is-clickable" href="readme.html#7.4.1.1.1_Contrução_da_Trie_0" data-path="#7.4.1.1.1_Contrução_da_Trie_0"><div class="tree-item-inner heading-link" heading-name="7.4.1.1.1 Contrução da Trie">7.4.1.1.1 Contrução da Trie</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#7.4.1.2_Links_de_Falha_0" data-path="#7.4.1.2_Links_de_Falha_0"><div class="tree-item-inner heading-link" heading-name="7.4.1.2 Links de Falha">7.4.1.2 Links de Falha</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#7.4.1.3_Busca_no_Texto_0" data-path="#7.4.1.3_Busca_no_Texto_0"><div class="tree-item-inner heading-link" heading-name="7.4.1.3 Busca no Texto">7.4.1.3 Busca no Texto</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#7.4.2_Burst_Sort_0" data-path="#7.4.2_Burst_Sort_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="7.4.2 Burst Sort">7.4.2 Burst Sort</div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#7.4.2.1_Divisão_das_Strings_em_Pedaços_0" data-path="#7.4.2.1_Divisão_das_Strings_em_Pedaços_0"><div class="tree-item-inner heading-link" heading-name="7.4.2.1 Divisão das Strings em Pedaços">7.4.2.1 Divisão das Strings em Pedaços</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#7.4.2.2_Uso_de_Baldes_0" data-path="#7.4.2.2_Uso_de_Baldes_0"><div class="tree-item-inner heading-link" heading-name="7.4.2.2 Uso de Baldes">7.4.2.2 Uso de Baldes</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#7.4.2.3_Estouro-Burst_0" data-path="#7.4.2.3_Estouro-Burst_0"><div class="tree-item-inner heading-link" heading-name="7.4.2.3 Estouro-Burst">7.4.2.3 Estouro-Burst</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#7.4.2.4_7.4.2.4._Ordenação_Local_0" data-path="#7.4.2.4_7.4.2.4._Ordenação_Local_0"><div class="tree-item-inner heading-link" heading-name="7.4.2.4 7.4.2.4. Ordenação Local">7.4.2.4 7.4.2.4. Ordenação Local</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#7.4.2.5_7.4.2.5._Geração_da_Lista_Ordenada_0" data-path="#7.4.2.5_7.4.2.5._Geração_da_Lista_Ordenada_0"><div class="tree-item-inner heading-link" heading-name="7.4.2.5 7.4.2.5. Geração da Lista Ordenada">7.4.2.5 7.4.2.5. Geração da Lista Ordenada</div></a><div class="tree-item-children"></div></div></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="1"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8_Guia_para_resolução_de_problemas_0" data-path="#8_Guia_para_resolução_de_problemas_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8 Guia para resolução de problemas">8 Guia para resolução de problemas</div></a><div class="tree-item-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8.1_Dicas_0" data-path="#8.1_Dicas_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8.1 Dicas">8.1 Dicas</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#8.1.1_Quando_usar_uma_Trie?_0" data-path="#8.1.1_Quando_usar_uma_Trie?_0"><div class="tree-item-inner heading-link" heading-name="8.1.1 Quando usar uma Trie?">8.1.1 Quando usar uma Trie?</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8.2_Problemas_Práticos_0" data-path="#8.2_Problemas_Práticos_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8.2 Problemas Práticos">8.2 Problemas Práticos</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#8.2.1_[Monitoria_de_LP2](https//www.spoj.com/problems/ADAINDEX/en/)_0" data-path="#8.2.1_[Monitoria_de_LP2](https//www.spoj.com/problems/ADAINDEX/en/)_0"><div class="tree-item-inner heading-link" heading-name="8.2.1 [Monitoria de LP2](https://www.spoj.com/problems/ADAINDEX/en/)">8.2.1 <span>Monitoria de LP2</span></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#8.2.2_[Nicks_semelhantes](https//codeforces.com/problemset/problem/514/C)_0" data-path="#8.2.2_[Nicks_semelhantes](https//codeforces.com/problemset/problem/514/C)_0"><div class="tree-item-inner heading-link" heading-name="8.2.2 [Nicks semelhantes](https://codeforces.com/problemset/problem/514/C)">8.2.2 <span>Nicks semelhantes</span></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#8.2.3_[Sintonia_computacional](https//www.spoj.com/problems/QN01/en/)_0" data-path="#8.2.3_[Sintonia_computacional](https//www.spoj.com/problems/QN01/en/)_0"><div class="tree-item-inner heading-link" heading-name="8.2.3 [Sintonia computacional](https://www.spoj.com/problems/QN01/en/)">8.2.3 <span>Sintonia computacional</span></div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8.3_Trie_ou_não_Trie?_Eis_a_questão_0" data-path="#8.3_Trie_ou_não_Trie?_Eis_a_questão_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8.3 Trie ou não Trie? Eis a questão">8.3 Trie ou não Trie? Eis a questão</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#8.3.1_Problema_1_Lista_Telefônica_0" data-path="#8.3.1_Problema_1_Lista_Telefônica_0"><div class="tree-item-inner heading-link" heading-name="8.3.1 Problema 1: Lista Telefônica">8.3.1 Problema 1: Lista Telefônica</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#8.3.2_Problema_2_Verificador_de_Anagramas_0" data-path="#8.3.2_Problema_2_Verificador_de_Anagramas_0"><div class="tree-item-inner heading-link" heading-name="8.3.2 Problema 2: Verificador de Anagramas">8.3.2 Problema 2: Verificador de Anagramas</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#8.3.3_Problema_3_Autocompletar_para_Contatos_0" data-path="#8.3.3_Problema_3_Autocompletar_para_Contatos_0"><div class="tree-item-inner heading-link" heading-name="8.3.3 Problema 3: Autocompletar para Contatos">8.3.3 Problema 3: Autocompletar para Contatos</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#8.3.4_Problema_4_Substring_Comum_Mais_Longa_0" data-path="#8.3.4_Problema_4_Substring_Comum_Mais_Longa_0"><div class="tree-item-inner heading-link" heading-name="8.3.4 Problema 4: Substring Comum Mais Longa">8.3.4 Problema 4: Substring Comum Mais Longa</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="readme.html#8.3.5_Problema_5_Banco_de_Senhas_0" data-path="#8.3.5_Problema_5_Banco_de_Senhas_0"><div class="tree-item-inner heading-link" heading-name="8.3.5 Problema 5: Banco de Senhas">8.3.5 Problema 5: Banco de Senhas</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8.4_Gabarito_dos_Problemas_Práticos_0" data-path="#8.4_Gabarito_dos_Problemas_Práticos_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8.4 Gabarito dos Problemas Práticos">8.4 Gabarito dos Problemas Práticos</div></a><div class="tree-item-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8.4.1_[Monitoria_de_LP2](https//www.spoj.com/problems/ADAINDEX/en/_&quot;null&quot;)_0" data-path="#8.4.1_[Monitoria_de_LP2](https//www.spoj.com/problems/ADAINDEX/en/_&quot;null&quot;)_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8.4.1 [Monitoria de LP2](https://www.spoj.com/problems/ADAINDEX/en/ &quot;null&quot;)">8.4.1 <span>Monitoria de LP2</span></div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.4.1.1_Análise_do_Problema_0" data-path="#8.4.1.1_Análise_do_Problema_0"><div class="tree-item-inner heading-link" heading-name="8.4.1.1 Análise do Problema">8.4.1.1 Análise do Problema</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.4.1.2_Estratégia_de_Solução_0" data-path="#8.4.1.2_Estratégia_de_Solução_0"><div class="tree-item-inner heading-link" heading-name="8.4.1.2 Estratégia de Solução">8.4.1.2 Estratégia de Solução</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.4.1.3_Complexidade_0" data-path="#8.4.1.3_Complexidade_0"><div class="tree-item-inner heading-link" heading-name="8.4.1.3 Complexidade">8.4.1.3 Complexidade</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8.4.2_[Nicks_semelhantes](https//codeforces.com/problemset/problem/514/C_&quot;null&quot;)_0" data-path="#8.4.2_[Nicks_semelhantes](https//codeforces.com/problemset/problem/514/C_&quot;null&quot;)_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8.4.2 [Nicks semelhantes](https://codeforces.com/problemset/problem/514/C &quot;null&quot;)">8.4.2 <span>Nicks semelhantes</span></div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.4.2.1_Análise_do_Problema_0" data-path="#8.4.2.1_Análise_do_Problema_0"><div class="tree-item-inner heading-link" heading-name="8.4.2.1 Análise do Problema">8.4.2.1 Análise do Problema</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.4.2.2_Estratégia_de_Solução_0" data-path="#8.4.2.2_Estratégia_de_Solução_0"><div class="tree-item-inner heading-link" heading-name="8.4.2.2 Estratégia de Solução">8.4.2.2 Estratégia de Solução</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.4.2.3_Complexidade_0" data-path="#8.4.2.3_Complexidade_0"><div class="tree-item-inner heading-link" heading-name="8.4.2.3 Complexidade">8.4.2.3 Complexidade</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8.4.3_[Sintonia_computacional](https//www.spoj.com/problems/QN01/en/)_0" data-path="#8.4.3_[Sintonia_computacional](https//www.spoj.com/problems/QN01/en/)_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8.4.3 [Sintonia computacional](https://www.spoj.com/problems/QN01/en/)">8.4.3 <span>Sintonia computacional</span></div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.4.3.1_Análise_do_Problema_0" data-path="#8.4.3.1_Análise_do_Problema_0"><div class="tree-item-inner heading-link" heading-name="8.4.3.1 Análise do Problema">8.4.3.1 Análise do Problema</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.4.3.2_Estratégia_de_Solução_0" data-path="#8.4.3.2_Estratégia_de_Solução_0"><div class="tree-item-inner heading-link" heading-name="8.4.3.2 Estratégia de Solução">8.4.3.2 Estratégia de Solução</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.4.3.3_Complexidade_0" data-path="#8.4.3.3_Complexidade_0"><div class="tree-item-inner heading-link" heading-name="8.4.3.3 Complexidade">8.4.3.3 Complexidade</div></a><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8.5_Gabarito_dos_Desafios_0" data-path="#8.5_Gabarito_dos_Desafios_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8.5 Gabarito dos Desafios">8.5 Gabarito dos Desafios</div></a><div class="tree-item-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8.5.1_Problema_1_Lista_Telefônica_0" data-path="#8.5.1_Problema_1_Lista_Telefônica_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8.5.1 Problema 1: Lista Telefônica">8.5.1 Problema 1: Lista Telefônica</div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.5.1.1_Análise_Passo_a_Passo_0" data-path="#8.5.1.1_Análise_Passo_a_Passo_0"><div class="tree-item-inner heading-link" heading-name="8.5.1.1 Análise Passo a Passo">8.5.1.1 Análise Passo a Passo</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8.5.2_Problema_2_Verificador_de_Anagramas_0" data-path="#8.5.2_Problema_2_Verificador_de_Anagramas_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8.5.2 Problema 2: Verificador de Anagramas">8.5.2 Problema 2: Verificador de Anagramas</div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.5.2.1_Análise_Passo_a_Passo_0" data-path="#8.5.2.1_Análise_Passo_a_Passo_0"><div class="tree-item-inner heading-link" heading-name="8.5.2.1 Análise Passo a Passo">8.5.2.1 Análise Passo a Passo</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8.5.3_Problema_3_Autocompletar_para_Contatos_0" data-path="#8.5.3_Problema_3_Autocompletar_para_Contatos_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8.5.3 Problema 3: Autocompletar para Contatos">8.5.3 Problema 3: Autocompletar para Contatos</div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.5.3.1_Análise_Passo_a_Passo_0" data-path="#8.5.3.1_Análise_Passo_a_Passo_0"><div class="tree-item-inner heading-link" heading-name="8.5.3.1 Análise Passo a Passo">8.5.3.1 Análise Passo a Passo</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8.5.4_Problema_4_Substring_Comum_Mais_Longa_0" data-path="#8.5.4_Problema_4_Substring_Comum_Mais_Longa_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8.5.4 Problema 4: Substring Comum Mais Longa">8.5.4 Problema 4: Substring Comum Mais Longa</div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.5.4.1_Análise_Passo_a_Passo_0" data-path="#8.5.4.1_Análise_Passo_a_Passo_0"><div class="tree-item-inner heading-link" heading-name="8.5.4.1 Análise Passo a Passo">8.5.4.1 Análise Passo a Passo</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-item-self is-clickable mod-collapsible" href="readme.html#8.5.5_Problema_5_Banco_de_Senhas_0" data-path="#8.5.5_Problema_5_Banco_de_Senhas_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="8.5.5 Problema 5: Banco de Senhas">8.5.5 Problema 5: Banco de Senhas</div></a><div class="tree-item-children"><div class="tree-item" data-depth="4"><a class="tree-item-self is-clickable" href="readme.html#8.5.5.1_Análise_Passo_a_Passo_0" data-path="#8.5.5.1_Análise_Passo_a_Passo_0"><div class="tree-item-inner heading-link" heading-name="8.5.5.1 Análise Passo a Passo">8.5.5.1 Análise Passo a Passo</div></a><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector("#right-sidebar"); rs.classList.toggle("is-collapsed", window.innerWidth < 768); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></div></div></body></html>